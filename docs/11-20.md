---
title: 《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 11-20 题
date: 2018-12-11 08:00:00
categories: 剑指 Offer
tags:
  - 剑指 Offer
mathjax: true
permalink: sword-for-offer-solutions/11-20
toc: true 
---

# 《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 11-20 题

### 第 11 题：旋转数组中的最小数字

传送门：[AcWing：旋转数组的最小数字](https://www.acwing.com/problem/content/20/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
>
> 输入一个升序的数组的一个旋转，输出旋转数组的最小元素。
>
> 例如数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为 $1$。
>
> 数组可能包含重复项。
>
> **注意**：数组内所含元素非负，若数组大小为0，请返回-1。
>
> 样例：
>
> 输入：`nums=[2, 2, 2, 0, 1]`
> 
> 输出：0

Java 代码：

```java
public class Solution {

    // 虽然可以通过，但是 O(n) 的复杂度并不理想
    public int minNumberInRotateArray(int[] array) {
        // {3,4,5,1,2}
        // 1 2 3 4 5
        int len = array.length;
        for (int i = 1; i < len - 1; i++) {
            if (array[i] < array[i - 1]) {
                return array[i];
            }
        }
        // 如果走到这里，说明数组是升序的，直接返回第 0 号索引的元素就可以了
        return array[0];
    }

    public static void main(String[] args) {
        // int[] nums = new int[]{3, 4, 5, 1, 2};
        int[] nums = new int[]{1, 2, 3, 4, 5};
        Solution solution = new Solution();
        int minNumberInRotateArray = solution.minNumberInRotateArray(nums);
        System.out.println(minNumberInRotateArray);
    }
}
```

思路1 ：这是典型的可以使用二分法解决的问题，应用二分法的模板。特别注意，数组可能包含重复项，因此中间项如果等于末尾项，例如：`[1, 1, 1, 1, 1, 0, 1]` ，不能砍掉一半，只能把末尾项排除掉。

Python 代码：

```python
class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        size = len(nums)
        if size == 0:
            return -1
        l = 0
        r = size - 1
        while l < r:
            mid = l + (r - l) // 2

            if nums[mid] < nums[r]:
                # mid 有可能是最小值
                # [7,8,1,2,3]
                r = mid
            elif nums[mid] > nums[r]:
                # mid 肯定不是最小值
                # [7,8,9,10,11,1,2,3]
                l = mid + 1
            else:
                # 都有可能，所以就把 r 排除了
                # [1,1,1,1,1,0,1]
                assert nums[mid] == nums[r]
                r = r - 1
        return nums[l]
```

思路2 ：还可以使用“分治法”，“分治法”就不用在乎有没有重复项了。但是“分治法”无异于把整个数组都看一遍，时间复杂度为 $O(n)$。

Python 代码：

```python
class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        size = len(nums)
        if size == 0:
            return -1
        if size == 1:
            return nums[0]
        return self.__findMin(nums, 0, size - 1)

    def __findMin(self, nums, left, right):
        if left == right:
            return nums[left]
        if left + 1 == right:
            return min(nums[left], nums[right])
        mid = left + (right - left) // 2
        return min(self.__findMin(nums, left, mid), self.__findMin(nums, mid + 1, right))
```

分析：可以使用二分查找的思想，因为最小的数字很可能出现在首位，从后向前扫描是求解这道题的重要技巧，否则需要分类讨论，就变得麻烦了（即让后面的指针向前移动）。

Java 代码：

```java
public class Solution2 {

    public int minNumberInRotateArray(int[] array) {
        int len = array.length;
        if (len == 0) {
            return 0;
        }
        int first = 0;
        int last = len - 1;
        while (first < last) {
            int mid = first + (last - first) / 2;
            if (array[mid] > array[last]) {
                first = mid + 1;
            } else if (array[mid] == array[last]) {
                last = last - 1;
            } else {
                last = mid;
            }
        }
        return array[first];
    }

    public static void main(String[] args) {
        // int[] nums = new int[]{3};
        // int[] nums = new int[]{3, 4, 5, 6, 7, 8, 9, 1, 2};
        // int[] nums = new int[]{1, 2, 3, 4, 5};
        int[] nums = new int[]{2, 2, 2, 1, 2};
        Solution2 solution2 = new Solution2();
        int minNumberInRotateArray = solution2.minNumberInRotateArray(nums);
        System.out.println(minNumberInRotateArray);
    }
}
```

### 第 12 题：矩阵中的路径

传送门：[AcWing：矩阵中的路径](https://www.acwing.com/problem/content/21/)。

> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
>
> 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
>
> 如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。
>
> **注意：**
>
> - 输入的路径不为空；
> - 所有出现的字符均为大写英文字母；
>
> 样例：
>
> ```
> matrix=
> [
>        ["A","B","C","E"],
>        ["S","F","C","S"],
>        ["A","D","E","E"]
> ]
> 
> str="BCCE" , return "true" 
> 
> str="ASAE" , return "false"
> ```

思路：典型的 floodfill 解法，本质上是递归回溯算法。

Python 代码：

```python
class Solution(object):
    directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]

    def hasPath(self, matrix, string):
        """
        :type matrix: List[List[str]]
        :type string: str
        :rtype: bool
        """
        rows = len(matrix)
        if rows == 0:
            return False
        cols = len(matrix[0])

        marked = [[False for _ in range(cols)] for _ in range(rows)]

        for i in range(rows):
            for j in range(cols):
                if self.__has_path(matrix, string, 0, i, j, marked, rows, cols):
                    return True
        return False

    def __has_path(self, matrix, word, index, start_x, start_y, marked, m, n):
        # 注意：首先判断极端情况
        if index == len(word) - 1:
            return matrix[start_x][start_y] == word[-1]
        if matrix[start_x][start_y] == word[index]:
            # 先占住这个位置，搜索不成功的话，要释放掉
            marked[start_x][start_y] = True
            for direction in self.directions:
                new_x = start_x + direction[0]
                new_y = start_y + direction[1]
                if 0 <= new_x < m and 0 <= new_y < n and not marked[new_x][new_y]:
                    if self.__has_path(matrix, word, index + 1, new_x, new_y, marked, m, n):
                        return True
            marked[start_x][start_y] = False
        return False


if __name__ == '__main__':
    matrix = [
        ["A", "B", "C", "E"],
        ["S", "F", "E", "S"],
        ["A", "D", "E", "E"]
    ]

    str = "ABCEFSADEESE"

    solution = Solution()
    result = solution.hasPath(matrix, str)
    print(result)
```

同 LeetCode 第 79 题，传送门：[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
> **示例:**
>
> ```
> board =
> [
>        ['A','B','C','E'],
>        ['S','F','C','S'],
>        ['A','D','E','E']
> ]
> ```
>
> 给定 word = "ABCCED", 返回 true.
> 给定 word = "SEE", 返回 true.
> 给定 word = "ABCB", 返回 false.

思路：其实就是 floodfill 算法，这是一个非常基础的算法，一定要掌握。特别要弄清楚，`marked` 数组的作用，一开始要占住这个位置，发现此路不通的时候，要释放掉。

Python 代码：

```python
class Solution:
    #         (x-1,y)
    # (x,y-1) (x,y) (x,y+1)
    #         (x+1,y)

    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]

    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """

        m = len(board)
        n = len(board[0])

        marked = [[False for _ in range(n)] for _ in range(m)]
        for i in range(m):
            for j in range(n):
                # 对每一个格子都从头开始搜索
                if self.__search_word(board, word, 0, i, j, marked, m, n):
                    return True
        return False

    def __search_word(self, board, word, index, start_x, start_y, marked, m, n):
        # 先写递归终止条件
        if index == len(word) - 1:
            return board[start_x][start_y] == word[index]

        # 中间匹配了，再继续搜索
        if board[start_x][start_y] == word[index]:
            # 先占住这个位置，搜索不成功的话，要释放掉
            marked[start_x][start_y] = True
            for direction in self.directions:
                new_x = start_x + direction[0]
                new_y = start_y + direction[1]
                if 0 <= new_x < m and 0 <= new_y < n and \
                        not marked[new_x][new_y] and \
                        self.__search_word(board, word,
                                           index + 1,
                                           new_x, new_y,
                                           marked, m, n):
                    return True
            marked[start_x][start_y] = False
        return False
```

Java 代码：

```java
public class Solution {

    /**
     *       x-1,y
     * x,y-1   x,y    x,y+1
     *       x+1,y
     */
    private int[][] direct = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
        int len = matrix.length;
        if (len == 0) {
            return false;
        }
        boolean[] marked = new boolean[len];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (dfs(matrix, rows, cols, str, str.length, marked, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(char[] matrix, int rows, int cols, char[] str, int len, boolean[] marked, int i, int j, int start) {
        // 匹配到最后，说明找到一条路径
        int index = getIndex(i, j, cols);
        if (start == len - 1) {
            return matrix[index] == str[start];
        }
        // 要特别小心！
        marked[index] = true;
        if (matrix[index] == str[start]) {
            // 当前匹配了，才开始尝试走后面的路
            for (int k = 0; k < 4; k++) {
                // 特别小心，一定是一个初始化的新的变量
                int newi = i + direct[k][0];
                int newj = j + direct[k][1];
                int nextIndex = getIndex(newi, newj, cols);
                if (inArea(newi, newj, rows, cols) && !marked[nextIndex]) {
                    // marked[nextIndex] = true; 不在这里设置
                    if (dfs(matrix, rows, cols, str, len, marked, newi, newj, start + 1)) {
                        return true;
                    }
                    // marked[nextIndex] = false; 不在这里设置
                }
            }
        }
        // 要特别小心！
        marked[index] = false;
        return false;
    }

    private int getIndex(int x, int y, int cols) {
        return x * cols + y;
    }

    private boolean inArea(int x, int y, int rows, int cols) {
        return x >= 0 && x < rows && y >= 0 && y < cols;
    }

    public static void main(String[] args) {
        char[] matrix = new char[]{'a', 'b', 't', 'g',
                'c', 'f', 'c', 's',
                'j', 'd', 'e', 'h'};
        int rows = 3;
        int cols = 4;
        Solution solution = new Solution();
        char[] str = "hscfdeh".toCharArray();
        boolean hasPath = solution.hasPath(matrix, rows, cols, str);
        System.out.println(hasPath);
    }
}
```

Java 代码：
```java
public class Solution {
    
    /**
     *       x-1,y
     * x,y-1   x,y    x,y+1
     *       x+1,y
     */
    private int[][] direct = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
        int len = matrix.length;
        if (len == 0) {
            return false;
        }
        boolean[] marked = new boolean[len];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (dfs(matrix, rows, cols, str, str.length, marked, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(char[] matrix, int rows, int cols, char[] str, int len, boolean[] marked, int i, int j, int start) {
        // 匹配到最后，说明找到一条路径
        int index = getIndex(i, j, cols);
        if (start == len - 1) {
            return matrix[index] == str[start];
        }
        // 要特别小心！
        marked[index] = true;
        if (matrix[index] == str[start]) {
            // 当前匹配了，才开始尝试走后面的路
            for (int k = 0; k < 4; k++) {
                // 特别小心，一定是一个初始化的新的变量
                int newi = i + direct[k][0];
                int newj = j + direct[k][1];
                int nextIndex = getIndex(newi, newj, cols);
                if (inArea(newi, newj, rows, cols) && !marked[nextIndex]) {
                    // marked[nextIndex] = true; 不在这里设置
                    if (dfs(matrix, rows, cols, str, len, marked, newi, newj, start + 1)) {
                        return true;
                    }
                    // marked[nextIndex] = false; 不在这里设置
                }
            }
        }
        // 要特别小心！
        marked[index] = false;
        return false;
    }

    private int getIndex(int x, int y, int cols) {
        return x * cols + y;
    }

    private boolean inArea(int x, int y, int rows, int cols) {
        return x >= 0 && x < rows && y >= 0 && y < cols;
    }

    public static void main(String[] args) {
        char[] matrix = new char[]{'a', 'b', 't', 'g',
                'c', 'f', 'c', 's',
                'j', 'd', 'e', 'h'};
        int rows = 3;
        int cols = 4;
        Solution solution = new Solution();
        char[] str = "hscfdeh".toCharArray();
        boolean hasPath = solution.hasPath(matrix, rows, cols, str);
        System.out.println(hasPath);
    }
}
```

### 第 13 题：机器人的运动范围

传送门：[AcWing：机器人的运动范围](https://www.acwing.com/problem/content/22/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 地上有一个 $m$ 行和 $n$ 列的方格，横纵坐标范围分别是 $0∼m−1$ 和 $0∼n−1$。
>
> 一个机器人从坐标 $(0,0)$ 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。
>
> 但是不能进入行坐标和列坐标的数位之和大于 $k$ 的格子。
>
> 请问该机器人能够达到多少个格子？
>
> 样例1：
>
> 输入：$k=7$，$m=4$，$n=5$
> 
> 输出：20
>
> 样例2：
>
> 输入：$k=18$，$m=40$，$n=40$
> 
> 输出：1484
> 
> 解释：当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。
>    但是，它不能进入方格（35,38），因为 3+5+3+8 = 19。
>
> **注意**:
>
> 1. `0<=m<=50`
> 2. `0<=n<=50`
> 3. `0<=k<=100`

思路：使用广度优先搜索（BFS），注意不是深度优先搜索（DFS）。

Python 代码：**特别注意，mark 的时候，一定是放入队列的时候就 mark，不是等到出队的时候 mark，否则会出现很多重复**

```python
class Solution(object):

    def __count_bit_sum(self, num):
        res = 0
        while num:
            res += num % 10
            num //= 10
        return res

    def __in_area(self, x, y, rows, cols):
        return 0 <= x < rows and 0 <= y < cols

    def movingCount(self, threshold, rows, cols):
        """
        :type threshold: int
        :type rows: int
        :type cols: int
        :rtype: int
        """
        if threshold < 0 or rows == 0 or cols == 0:
            return 0

        if threshold == 0:
            return 1

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        marked = [[False for _ in range(cols)] for _ in range(rows)]

        queue = [(0, 0)]
        res = 0

        while queue:
            top_x, top_y = queue.pop(0)

            for direction in directions:
                new_x = top_x + direction[0]
                new_y = top_y + direction[1]

                if self.__in_area(new_x, new_y, rows, cols) \
                        and not marked[new_x][new_y] \
                        and self.__count_bit_sum(new_x) + self.__count_bit_sum(new_y) <= threshold:
                    queue.append((new_x, new_y))
                    # 注意：应该写在这里，而不是 pop 出队列的时候
                    marked[new_x][new_y] = True
                    res += 1
        return res


if __name__ == '__main__':
    k = 18
    m = 40
    n = 40
    solution = Solution()
    result = solution.movingCount(k, m, n)
    print(result)
```

### 第 14 题：剪绳子

说明：同 LeetCode 343 题。

传送门：[AcWing 25. 剪绳子](https://www.acwing.com/problem/content/24/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 给你一根长度为 $n$ 的绳子，请把绳子剪成 $m$  段（$m$、$n$ 都是整数，$2 \le n \le 58^2$ 并且 $m \ge2$）。
>
> 每段的绳子的长度记为 `k[0]、k[1]、……、k[m]`。`k[0]k[1] … k[m]` 可能的最大乘积是多少？
>
> 例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。
>
> 样例：
>
> 输入：8
> 
> 输出：18

> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

分析：这道题在牛客网上没有 online judge ，我们可以去完成 LeetCode 上第 343 题检验自己的代码是否编写正确。

动态规划。关键在于画出树形结构图。

状态：这个状态就是题目中要我们求的。把整数 `i` 至少分割成 $2$ 个部分，各个部分都大于 $0$，它们的乘积。

状态转移方程：用  `j` 遍历 `1, 2, ..., i - 1` ，要么分割成 `i - j` 和 `j` ，要么分隔成  `j` 和 `dp[i - j]` ，取最大者。

Python 代码：`dp[0]` 这个位置没有使用

```python
class Solution(object):
    def maxProductAfterCutting(self, length):
        """
        :type length: int
        :rtype: int
        """

        assert length > 1

        dp = [0 for _ in range(length + 1)]

        dp[1] = 1

        for i in range(2, length + 1):
            for j in range(1, i):
                dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
        return dp[length]
```

Java 代码：使用动态规划

```java
class Solution {
    public int integerBreak(int n) {
        if (n <= 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            int max = 0;
            for (int j = 1; j < i; j++) {
                max = max3(max, j * (i - j), j * dp[i - j]);
            }
            dp[i] = max;
        }
        return dp[n];
    }

    private int max3(int num1, int num2, int num3) {
        return Integer.max(Integer.max(num1, num2), num3);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int integerBreak = solution.integerBreak(8);
        System.out.println(integerBreak);
    }
}
```

Java 代码：使用贪心算法

```java
class Solution2 {
    public int integerBreak(int n) {
        if (n <= 2) {
            return 1;
        }
        if (n == 3) {
            return 2;
        }
        if (n == 4) {
            return 4;
        }
        // 接下来就是 n >= 5 的时候的逻辑了
        int res = 1;
        while (n > 4) {
            res *= 3;
            n -= 3;
        }
        res *= n;
        return res;
    }

    public static void main(String[] args) {
        Solution2 solution2 = new Solution2();
        int integerBreak = solution2.integerBreak(8);
        System.out.println(integerBreak);
    }
}
```

### LeetCode 343 题：整数拆分

传送门：[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

> 给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
>
> **示例 1:**
>
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1。
>
> **示例 2:**
>
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
>
> **说明:** 你可以假设 *n* 不小于 2 且不大于 58。

分析：这是一个很经典的问题。可以使用贪心算法。

贪心算法：$2(n-2)>n$ 得到 $n > 4$，$3(n-3)>n$ ，得到 $n>4.5$，即 $n$ 大于等于 $5$ 的时候。

结论：不能包含 $1$ ，所有的加法因子只能有 $2$ 和 $3$，最多只有 $2$ 个 $2$，因此加法因子里没有 $4$ 。

![image-20190108000201883](https://ws2.sinaimg.cn/large/006tNc79ly1fyygsgdhsxj30za0digot.jpg)

Java 代码：

```java
class Solution2 {
    public int integerBreak(int n) {
        if (n <= 2) {
            return 1;
        }
        if (n == 3) {
            return 2;
        }
        if (n == 4) {
            return 4;
        }
        // 接下来就是 n >= 5 的时候的逻辑了
        int res = 1;
        while (n > 4) {
            res *= 3;
            n -= 3;
        }
        res *= n;
        return res;
    }

    public static void main(String[] args) {
        Solution2 solution2 = new Solution2();
        int integerBreak = solution2.integerBreak(8);
        System.out.println(integerBreak);
    }
}
```

C++ 代码：

![image-20190108000417713](http://upload-images.jianshu.io/upload_images/414598-92c4cf93cd81b59f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




### 第 16 题：数值的整数次方（快速幂）

传送门：[AcWing：数值的整数次方](https://www.acwing.com/problem/content/26/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 实现函数*double Power(double base, int exponent)*，求*base*的 *exponent*次方。
>
> 不得使用库函数，同时不需要考虑大数问题。
>
> **注意：**
>
> - 不会出现底数和指数同为 0 的情况
>
> 样例1：
>
> 输入：10 ，2
> 
> 输出：100
>
> 样例2：
>
> 输入：10 ，-2  
> 
> 输出：0.01

分析：数值的整数次方，要处理一些细节问题，加法变成乘法。考虑底数为 $0$ 的时候，指数不能为负数。

思路1：使用递归

Python 代码：

```python
class Solution(object):
    def Power(self, base, exponent):
        """
        :type base: float
        :type exponent: int
        :rtype: float
        """

        if exponent == 0:
            return 1

        if exponent < 0:
            return 1 / self.Power(base, -exponent)

        # 如果是奇数
        if exponent & 1:
            return base * self.Power(base, exponent - 1)
        return self.Power(base * base, exponent >> 1)
```

思路2：非递归的写法，把 exponent 想象成二进制。

Python 代码：在理解的基础上记住这个写法

```python
class Solution(object):
    def Power(self, base, exponent):
        """
        :type base: float
        :type exponent: int
        :rtype: float
        """

        if exponent < 0:
            base = 1 / base
            # 负数变成正数
            exponent = -exponent

        res = 1
        while exponent:
            if exponent & 1:
                res *= base
            base *= base
            exponent >>= 1
        return res
```

> 给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent 。求 base 的 exponent 次方。

求解思路与关键

+ 注意分类讨论与与递归函数的设计。

+ 关键：将循环变成递归操作，每次折半求值，避免死板做循环，这种感觉像加法变乘法。

+ 注意细节：底数为 0 的时候，指数为负数是没有意义的

+ 精确计算，转成浮点数 0.125：

```java
System.out.println((double) 1 / 8);
```

+ 右移 1 位运算等价于“除以 2”：
```java
// exponent 指数，exponent >> 1 表示将指数除以 2
System.out.println(exponent >> 1);
```

+ 使用位运算的 与 运算符代替了求余数运算，来判断一个数是奇数还是偶数：
```java
if ((exponent & 1) == 0) {
```

Java 代码：

```java
public class Solution {

    public double Power(double base, int exponent) {
        // 先把极端情况考虑到
        // 不能用 == 比较两个浮点数是否相等，因为有误差
        if (equals(base, 0) && exponent < 0) {
            throw new IllegalArgumentException("当底数为 0 的时候，指数为负数没有意义");
        }
        if (exponent == 0) {
            return 1.0;
        }
        // 下面将指数的两种情况合并成一种情况考虑
        if (exponent > 0) {
            return power(base, exponent);
        } else {
            return power(1 / base, -exponent);
        }
    }

    public double power(double base, int exponent) {
        if (exponent == 0) {
            return 1.0;
        }
        if (exponent % 2 == 0) {
            double square = power(base, exponent / 2);
            return square * square;
        } else {
            double square = power(base, (exponent - 1) / 2);
            return square * square * base;
        }
    }

    private boolean equals(double num1, double num2) {
        return num1 - num2 < 0.000001 && num1 - num2 > -0.000001;
    }
}
```

Java 代码：

```java
public class Solution {

    public double Power(double base, int exponent) {
        if (exponent == 0) {
            return 1;
        }
        if (exponent < 0) {
            return 1 / Power(base, -exponent);
        }
        // 使用位运算的 与 运算符代替了求余数运算，来判断一个数是奇数还是偶数
        if ((exponent & 1) == 0) {
            double square = Power(base, exponent >> 1);
            return square * square;
        } else {
            double square = Power(base, (exponent - 1) >> 1);
            return square * square * base;
        }
    }

    public static void main(String[] args) {
        int base = 3;
        int exponent = -3;
        Solution solution = new Solution();
        double result1 = solution.Power(base, exponent);
        System.out.println(result1);
        exponent = 6;
        double result2 = solution.Power(base, exponent);
        System.out.println(result2);
        // exponent 指数，exponent >> 1 表示将指数除以 2
        System.out.println(exponent >> 1);
    }
}
```

### LeetCode 第 50 题：$Pow(x, n)$

传送门：[50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)。

> 实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。
>
> **示例 1:**
>
> ```
> 输入: 2.00000, 10
> 输出: 1024.00000
> ```
>
> **示例 2:**
>
> ```
> 输入: 2.10000, 3
> 输出: 9.26100
> ```
>
> **示例 3:**
>
> ```
> 输入: 2.00000, -2
> 输出: 0.25000
> 解释: 2-2 = 1/22 = 1/4 = 0.25
> ```
>
> **说明:**
>
> - -100.0 < *x* < 100.0
> - *n* 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

思路1：使用循环，把指数 $n$ 想成二进制

Python 代码：

```python
class Solution:
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        
        
        if n < 0:
            x = 1 / x
            n = - n
        res = 1
        while n:
            if n & 1 == 1:
                res *= x
            # 注意：这里不要写成  res *= res
            x *= x 
            n >>= 1
        return res
```

思路2：将循环变成递归操作，每次折半求值，避免死板做循环，这种感觉像加法变乘法。（脑子里回忆公式）。注意细节：底数为 $0$ 的时候，指数为负数是没有意义的。

Python 代码：递归写法：**注意边界条件**

```python
class Solution:
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        # 对 x = 0 ， n < 0 还要做特判
        if n == 0:
            return 1
        if n < 0:
            return 1 / self.myPow(x, -n)

        if n & 1:
            return x * self.myPow(x, n - 1)
        return self.myPow(x * x, n // 2)
```

基本的写法：

https://blog.csdn.net/happyaaaaaaaaaaa/article/details/76552127

![《剑指 Offer （第 2 版）》第 16 题：数值的整数次方（快速幂）-1](http://upload-images.jianshu.io/upload_images/414598-95b1ba5229d3f933.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

模板写法1：

![《剑指 Offer （第 2 版）》第 16 题：数值的整数次方（快速幂）-2](http://upload-images.jianshu.io/upload_images/414598-a729b89eecb30d06.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

模板写法2：

![《剑指 Offer （第 2 版）》第 16 题：数值的整数次方（快速幂）-3](http://upload-images.jianshu.io/upload_images/414598-0e2a30015099f0b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 第 17 题：打印从 1 到最大的 n 位数 

传送门：[牛客网 online judge 地址](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

### 第 18-1 题：在 $O(1)$ 时间删除链表结点

传送门：[AcWing：在 O(1) 时间删除链表结点](https://www.acwing.com/problem/content/85/)。

> 给定单向链表的一个节点指针，定义一个函数在$O(1)$ 时间删除该结点。
>
> 假设链表一定存在，并且该节点一定不是尾节点。
>
> 样例：
>
> 输入：链表 `1->4->6->8`，删掉节点：第 2 个节点即 6（头节点为第 0 个节点）
>
> 输出：新链表 `1->4->8`

思路：待删除的结点是末尾结点的情况比较容易忽略，刚好题目中说“该节点一定不是尾节点”。

Python 代码：

```python
# 28. 在O(1)时间删除链表结点
# 给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。
#
# 假设链表一定存在，并且该节点一定不是尾节点。
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void
        """
        # 先保存下一个结点
        next_node = node.next
        # 把下一个结点的 val 赋值给当前结点
        node.val = next_node.val
        # 把当前结点的 next 指针指向下一个结点的 next 指针
        node.next = next_node.next
        # 切断下一个结点与原链表的连接
        next_node.next = None
```

C++ 代码：

![image-20190108002212753](https://ws2.sinaimg.cn/large/006tNc79ly1fyyhdg1a3zj30m40fsteq.jpg)

### 第 18-2 题：删除链表中重复的结点

同 LeetCode 第82 题。

传送门：[AcWing：删除链表中重复的节点](https://www.acwing.com/problem/content/27/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。
>
> 样例1：
>
> 输入：`1->2->3->3->4->4->5`
> 
> 输出：`1->2->5`
>
> 样例2：
>
> 输入：`1->1->1->2->3`
> 
> 输出：`2->3`

思路：因为头结点可能被删，所以要设置一个虚拟头结点。

Python 写法：

```python
class Solution(object):
    def deleteDuplication(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head is None:
            return None

        dummy = ListNode(-1)
        dummy.next = head
        cur = dummy

        # 一下子要看两个，所以是
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                # 删除的起点至少是 cur.next.next
                del_node = cur.next.next

                while del_node.next and del_node.val == del_node.next.val:
                    del_node = del_node.next
                # 来到了一个新的结点，值不同

                cur.next = del_node.next
                del_node.next = None
            else:
                cur = cur.next

        return dummy.next
```

Java 代码：

```java
class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }

    public ListNode(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("arr can not be empty");
        }
        this.val = arr[0];
        ListNode cur = this;
        for (int i = 1; i < arr.length; i++) {
            cur.next = new ListNode(arr[i]);
            cur = cur.next;
        }
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        ListNode cur = this;
        while (cur != null) {
            s.append(cur.val + " -> ");
            cur = cur.next;
        }
        s.append("NULL");
        return s.toString();
    }
}

public class Solution {
    public ListNode deleteDuplication(ListNode pHead) {
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = pHead;
        ListNode curNode = dummyNode;
        while (curNode.next != null && curNode.next.next != null) {
            ListNode next = curNode.next;
            ListNode nextNext = next.next;
            if (next.val == nextNext.val) {
                while (nextNext.next != null && nextNext.val == nextNext.next.val) {
                    nextNext = nextNext.next;
                }
                ListNode delNode = nextNext;
                curNode.next = delNode.next;
                delNode.next = null;
            } else {
                curNode = curNode.next;
            }
        }
        return dummyNode.next;
    }

    public static void main(String[] args) {
        int[] nums = new int[]{1, 2, 3, 3, 4, 4, 5};
        ListNode head = new ListNode(nums);
        System.out.println(head);

        Solution solution = new Solution();
        ListNode deleteDuplication = solution.deleteDuplication(head);
        System.out.println(deleteDuplication);
    }
}
```

### LeetCode 第 82 题： 删除排序链表中的重复元素 II

传送门：[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)。

> 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 *没有重复出现* 的数字。
>
> **示例 1:**
>
> 输入: `1->2->3->3->4->4->5`
> 输出: `1->2->5`
>
> **示例 2:**
>
> 输入: `1->1->1->2->3`
> 输出: `2->3`

Java 代码：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
       if (head == null) {
            return null;
        }
        // 只要涉及头结点的操作，我们都设立虚拟头结点
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;
        ListNode curNode = dummyNode;
        while (curNode.next != null && curNode.next.next != null) {
            // 如果接连两个结点的 val 相等，至少要把它们都删掉
            if (curNode.next.val == curNode.next.next.val) {
                // 要删除的起点至少应该是当前判断相同的结点的第 2 个
                ListNode delNode = curNode.next.next;
                // 如果后面还有相同的结点，delNode 后移一位，即 delNode 应该是指向相同的结点的最后一个
                while (delNode.next != null && delNode.next.val == delNode.val) {
                    delNode = delNode.next;
                }
                curNode.next = delNode.next;
                delNode.next = null;
            } else {
                curNode = curNode.next;
            }
        }
        return dummyNode.next; 
    }
}
```

### LeetCode 第 83 题： 删除排序链表中的重复元素

传送门：[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)。

> 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
>
> **示例 1:**
>
> ```
> 输入: 1->1->2
> 输出: 1->2
> ```
>
> **示例 2:**
>
> ```
> 输入: 1->1->2->3->3
> 输出: 1->2->3
> ```

Java 代码：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode curNode = head;
        while (curNode != null && curNode.next != null) {
            if (curNode.val == curNode.next.val) {
                ListNode delNode = curNode.next;
                // 继续向前找，看看，还有没有可以删除的结点
                while (delNode.next != null && delNode.next.val == delNode.val) {
                    delNode = delNode.next;
                }
                // 穿针引线
                curNode.next = delNode.next;
                delNode.next = null;
            } else {
                curNode = curNode.next;
            }
        }
        return head;
    }
}
```

### 第 19 题：正则表达式匹配

传送门：[正则表达式匹配](https://www.acwing.com/problem/content/28/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 请实现一个函数用来匹配包括`'.'`和`'*'`的正则表达式。
>
> 模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含0次）。
>
> 在本题中，匹配是指字符串的所有字符匹配整个模式。
>
> 例如，字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但是与`"aa.a"`和`"ab*a"`均不匹配。
>
> 样例：
>
> ```
> 输入：
> 
> s="aa"
> p="a*"
> 
> 输出:true
> ```

思路：这题考察的是动态规划。笔记我写在这里了：[《剑指 Offer》（第 2 版）第 19 题：正则表达式匹配](https://www.jianshu.com/p/0130b5a5e81e)。

Python 代码：

```python
class Solution(object):

    # 状态：dp[i][j] 表示 s 中前 i 个字符与 p 的前 j 个字符组成的表示式是否匹配
    # i 和 j 表示个数
    # 代码中出现 i 均表示 s 中的索引或者个数
    # 代码中出现 j 均表示 p 中的索引或者个数
    # 出现 -1 都表示当前考虑的
    # 出现 -2 都表示当前再前一个

    # 参考资料：http://www.voidcn.com/article/p-zioiffqq-mm.html

    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        n = len(s)
        m = len(p)

        dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]

        # 当 s 和 p 的长度都为 0 的时候，定义成匹配
        dp[0][0] = True

        # 特判
        for j in range(2, m + 1):
            if p[j - 1] == '*' and dp[0][j - 2]:
                dp[0][j] = True

        # 下面分别对字符串 s 和模式串 p 进行匹配
        for i in range(1, n + 1):
            for j in range(1, m + 1):

                if s[i - 1] == p[j - 1] or p[j - 1] == '.':
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == '*':
                    # 这是最麻烦的情况

                    if p[j - 2] != s[i - 1] and p[j - 2] != '.':
                        # 例子：s a
                        #        j-1
                        #      p b    *
                        #        j-2  j-1
                        # 此时只能把 * 当成 0 次，即 * 和它之前的字母不出现，所以一下子要减去 2
                        # p[j - 2] != '.' 这一点别忘了
                        # 不能匹配
                        dp[i][j] = dp[i][j - 2]
                    else:
                        # 接下来是可以匹配
                        # 例子：s a
                        #        j-1
                        #      p .    *
                        #        j-2  j-1
                        # 此时把 * 当成 0 次，
                        # 此时把 * 当成 1 次，
                        # 此时把 * 当成 多 次，直接把 i - 1 ，这是最难的地方
                        dp[i][j] = dp[i][j - 2] or dp[i][j - 1] or dp[i - 1][j]
        return dp[n][m]
```

---

方法2：递归的写法。

参考资料：一个网红的解法：http://www.cnblogs.com/grandyang/p/4461713.html。有解法 1 还有解法2。

![image-20190125154510545](https://ws3.sinaimg.cn/large/006tNc79ly1fzivl264vtj313w0oq46i.jpg)

网红写法：https://blog.csdn.net/hk2291976/article/details/51165010

说明：这个网红还写了 leetbook。

![image-20190125154654023](https://ws1.sinaimg.cn/large/006tNc79ly1fzivmsycvaj32860s47b9.jpg)



参考资料：https://zhuanlan.zhihu.com/p/37647267。

采用递归的解题方法，递归的终止条件是：

1、如果 $s$ 和 $p$ 都只有一个字符，相等的充要条件是，它们相等，或者 $p$ 是 `'.'`；

其他递归情况：

1、如果 $p$ 的第二个字符不是 `'*'`，那么如果 $s$ 是空，返回 `false`，如果 $s[0]$ 和 $p[0]$ 能匹配上，那么递归 `s.substr(1), p.substr(1)`；

==坏就坏在，如果 $p$ 的第二个字符是 `'*'`==。

2、如果 $p$ 的第二个字符是 **'*'**，因为我们知道 '*' 可以代表 '*' 之前的元素个数是 $0$ 个或者 $1$ 个或者多个，所以如果 $s$ 的前 $k$ 个元素个 $p[0]$ 一样，那么它们有可能都被匹配到，也有可能一个都不会被匹配上。

C++ 写法：

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        if(p.empty())return s.empty();
        if(p.size() == 1) {
             return(s.size() == 1 && (s[0] == p[0] || p[0] == '.'));
        }
       
        if(p[1] != '*')  {
            if(s.empty())return false;
            return (s[0] == p[0] || p[0] == '.')&& isMatch(s.substr(1), p.substr(1));
        }
        // 走到这里 p[1] == '*'，下面的 4 行代表比较难理解
        while(!s.empty() && (s[0] == p[0] || p[0] == '.')) {
            if(isMatch(s, p.substr(2))) return true;
            s = s.substr(1);
        }
        return isMatch(s, p.substr(2));
    }
};
```

要求：请实现一个函数用来匹配包括 `.` 和 `*` 的正则表达式。模式中的字符 `.` 表示任意一个字符，而 `*` 表示它前面的字符可以出现任意次，包括 $0$ 次。

LeetCode 第 10 题，传送门：[10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/description/)，难度是：**困难**。

使用动态规划：

![image-20190108003842166](https://ws3.sinaimg.cn/large/006tNc79ly1fyyhum1aunj30xg0lggwc.jpg)

dp 函数这么写。

![image-20190108004253180](https://ws3.sinaimg.cn/large/006tNc79ly1fyyhyybbgjj30r20c8wmm.jpg)

思路：当字符串只有一个字符时，直接进行判断，否则进入下面两种递归。

两种递归情况：1、当模式中的第二个字符不是 `*` 时：

（1）如果字符串第一个字符和模式中的第一个字符相匹配或是字符 `.` 那么字符串和模式都后移一个字符，然后匹配剩余 的；

（2）如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回 `false`。

2、当模式中的第二个字符是 `*` 时：

如果“字符串”第一个字符跟“模式串”第一个字符不匹配，则模式后移 $2$ 个字符，继续匹配；

如果“字符串”第一个字符跟“模式串”第一个字符匹配或是字符 `.` ，可以有 $3$ 种匹配方式：

（1）模式后移 $2$ 字符，相当于 `x` 被忽略；

（2）字符串后移  $1$ 字符，模式后移 $2$ 字符；

（3）字符串后移 $1$ 字符，模式不变，即继续匹配字符下一位，因为可以匹配多位。

![image-20190107154329317](https://ws4.sinaimg.cn/large/006tNc79ly1fyy2dqxjh2j31cm0tc78b.jpg)

![image-20190107154342220](https://ws2.sinaimg.cn/large/006tNc79ly1fyy2dyvq77j31940u0wkl.jpg)

### 第 20 题：表示数值的字符串

传送门：[ 表示数值的字符串](https://www.acwing.com/problem/content/description/29/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
>
> 例如，字符串`"+100"`,`"5e2"`,`"-123"`,`"3.1416"`和`"-1E-16"`都表示数值。
>
> 但是`"12e"`,`"1a3.14"`,`"1.2.3"`,`"+-5"`和`"12e+4.3"`都不是。
>
> **注意**:
>
> 1. 小数可以没有整数部分，例如.123等于0.123；
> 2. 小数点后面可以没有数字，例如233.等于233.0；
> 3. 小数点前面和后面可以有数字，例如233.666;
> 4. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；
> 5. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4;
>
> 样例：
>
> 输入: "0"
> 
> 输出: true

Python 代码：

```python
class Solution(object):
    def isNumber(self, s):
        """
        :type s: str
        :rtype: bool
        """
        size = len(s)

        # 1、去掉多余的空格
        i = 0
        while i < size and s[i] == ' ':
            i += 1

        j = size - 1
        while j >= 0 and s[j] == ' ':
            j -= 1
        if i > j:
            return False

        s = s[i:j - i + 1]
        
        # 2、首字母可以是加号或者减号
        if s[0] == '+' or s[0] == '-':
            s = s[1:]
        
        if len(s) == 0:
            return False
        # 3、只有 1 个点，不行
        if len(s) == 1 and s[0] == '.':
            return False
				# 4、下面对点的个数和 e 的个数展开讨论
        
        # 点的个数
        dot_cnt = 0
        # e 的个数
        e_cnt = 0

        size = len(s)
        i = -1
        while i < size - 1:
            i += 1
            if '0' <= s[i] <= '9':
                continue
            elif s[i] == '.':
                dot_cnt += 1
                # 如果没有 e，并且点的数量大于 1，不符合要求
                if e_cnt or dot_cnt > 1:
                    return False
            elif s[i] == 'e' or s[i] == 'E':
                e_cnt += 1
                if i == 0 or i == size - 1 or e_cnt > 1:
                    return False
                # '.' 后面不能加上
                if i == 1 and s[0] == '.':
                    return False
                if s[i + 1] == '+' or s[i + 1] == '-':
                    if i + 2 == size:
                        return False
                    i += 1
            else:
                return False
        return True


if __name__ == '__main__':
    solution = Solution()
    s = '123.45e+6'
    result = solution.isNumber(s)
    print(result)
```

“大雪菜”的解法：https://www.acwing.com/solution/acwing/content/737/。

C++ 代码：

![image-20190108005159319](https://ws3.sinaimg.cn/large/006tNc79ly1fyyi8g5kfkj31j40tix3l.jpg)

C++ 代码：

```c++
class Solution {
public:
    bool isNumber(string s) {
        int i = 0;
        while (i < s.size() && s[i] == ' ') i ++ ;
        int j = s.size() - 1;
        while (j >= 0 && s[j] == ' ') j -- ;
        if (i > j) return false;
        s = s.substr(i, j - i + 1);

        if (s[0] == '-' || s[0] == '+') s = s.substr(1);
        if (s.empty() || s[0] == '.' && s.size() == 1) return false;

        int dot = 0, e = 0;
        for (int i = 0; i < s.size(); i ++ )
        {
            if (s[i] >= '0' && s[i] <= '9');
            else if (s[i] == '.')
            {
                dot ++ ;
                if (e || dot > 1) return false;
            }
            else if (s[i] == 'e' || s[i] == 'E')
            {
                e ++ ;
                if (i + 1 == s.size() || !i || e > 1 || i == 1 && s[0] == '.') return false;
                if (s[i + 1] == '+' || s[i + 1] == '-')
                {
                    if (i + 2 == s.size()) return false;
                    i ++ ;
                }
            }
            else return false;
        }
        return true;
    }
};


```

作者：yxc
链接：https://www.acwing.com/solution/acwing/content/737/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

（本节完）