# 第 12.5 节 N 皇后问题

「回溯算法」是遍历（深度优先遍历）算法，配合适当的「剪枝」技巧，可以用于 **搜索** 符合要求的所有的解。

之所以这个算法中有「回溯」这个词，是由于「回溯算法」使用一份状态变量去搜索整个「状态空间」，在搜索（或者说遍历）的过程中，每一步的 **尝试** 和 **回退** 代价较小。因此「回溯算法」很多时候能够帮助我们解决一些游戏类的问题，这是因为有些游戏类问题在人脑看来「状态空间」很大，但是对于计算机来说，计算机是擅长计算的，可以用于完成一些 **适当规模** 的问题。

可以认为「回溯算法」是早期的人工智能算法，有一些教程上称「回溯算法」为「暴力搜索」也正是基于「回溯算法」





因为人脑是很难穷举完所有可能的情况，但是我们可以通过编程，帮助我们玩好一些游戏。因此在一些人工智能的书籍上，很多时候会先介绍回溯算法，回溯算法是早期的人工智能。








> *n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL2FsaXl1bi1sYy11cGxvYWQvdXBsb2Fkcy8yMDE4LzEwLzEyLzgtcXVlZW5zLnBuZw?x-oss-process=image/format,png)

上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

```
输入: 4
输出: [
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。
```

**分析**：以 4 皇后问题为例，它的「搜索」过程如下，大家完全可以在纸上模拟下面这个过程：

![0051.gif](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzlkNDNkMDM4OTc4NDY1YmMxZjM1ZTA4OGRlNGNiOGI4ZDI2MDEyOWRiMzM1MTAzNjMxN2EyMjQ2ZTEyMTI0N2YtMDA1MS5naWY){:width=500}
搜索问题的解决策略是画递归树。还以 4 皇后问题为例，画出的递归树如下。

以下假定给棋盘的每一行从左到右标记为 $1$、$2$、$3$、$4$：

![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2E4ODI2MzkxMTY2MmYxOTJmM2YwNWIxNGU5NDg3MzEwZGU4YjVmMGE3MzM3NjE1Nzk0N2UzN2QwYTAwNDAxOGEtaW1hZ2UucG5n?x-oss-process=image/format,png)
{:align=center}

那么，递归搜索的过程可以表示成如下递归树（只画了 2 层）：

![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2QzNjcxZTk1MGMyZWE1OWU0Y2M4NWVkNGNjN2FjYmRlMmJmNzU5ZGZjZTUwYjFkN2MwNDczNzdjMDE5NjkzNDgtaW1hZ2UucG5n?x-oss-process=image/format,png){:width=600}
这其实就是「全排列」问题 + 「剪枝」 。 「剪枝」的依据就是题目中描述的「N 皇后」问题的规则，有了使用数组 `used` （哈希表、位图）的经验，我们可以多设置一些「状态」，下面依次进行分析：

1. 由于是一行一行摆放，因此这些「皇后」一定不在同一行，无需额外设置状态；
2. 为了保证不再同一列，即不能出现 `[2, 2, 1, 3]` 这种情况，第 46 的数组 `used`（哈希表、位图）就是这样的「状态」 变量；
3. 为了保证至少两个皇后不同时出现在主对角线或者副对角线，我们的策略是，只要「检测」到新摆放的「皇后」与已经摆放好的「皇后」冲突，就尝试摆放下一个位置，在「无处安放」的时候「剪枝」。

下面我们研究一下主对角线或者副对角线上的元素有什么特性。我们此时能掌握的信息只有行和列的索引，不妨将它标注在棋盘上。

![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzMwMDA2NGM1NWUwZTM1MTNlY2U4MjU0NTFlMzg1N2Y3N2JiYzQ3ODhiMGJlYjk3NGFlNzJhMDZlMGUxMWRkOGYtaW1hZ2UucG5n?x-oss-process=image/format,png)


+ 为此，我们可以像数组 ` used` 那样，再为「主对角线」和「副对角线」设置相应的数组变量，只要排定一个「皇后」的位置，就相应低占住相应的位置；
+ 因为位置有限，可以使用数组，不过我个人先使用的哈希表，原因是副对角那里使用数组的话还要计算一个偏差，另外，数组的元素个数也要归纳得到，因此，使用哈希表表示「状态」，我认为在编码上是比较简洁的；
+ 写对了「哈希表」以后，说明我们的思路是没有问题的，然后再写「数组」作为状态，最后写「位图」作为「状态」 。

得到一个符合要求的 「全排列」以后，生成棋盘的代码就很简单了。

**参考代码 **：使用哈希表分别记录「列占用情况」 、 「主对角线占用情况」 、 「副对角线占用情况」。 

Java 代码：

```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

public class Solution {

    private int n;
    private boolean[] col;
    private boolean[] main;
    private boolean[] sub;
    private List<List<String>> res;


    public List<List<String>> solveNQueens(int n) {
        res = new ArrayList<>();
        if (n == 0) {
            return res;
        }

        this.n = n;

        col = new boolean[n];
        main = new boolean[2 * n - 1];
        sub = new boolean[2 * n - 1];
        Deque<Integer> path = new ArrayDeque<>();
        dfs(0, path);
        return res;
    }

    private void dfs(int row, Deque<Integer> path) {
        // 深度优先遍历到下标为 n，表示 [0.. n - 1] 已经填完，得到了一个结果集
        if (row == n) {
            List<String> board = convert2board(path);
            res.add(board);
            return;
        }

        // 针对下标为 row 的每一列，尝试是否可以放置
        for (int i = 0; i < n; i++) {
            if (!col[i] && !main[row + i] && !sub[row - i + n - 1]) {
                path.addLast(i);
                col[i] = true;
                main[row + i] = true;
                sub[row - i + n - 1] = true;

                dfs(row + 1, path);

                sub[row - i + n - 1] = false;
                main[row + i] = false;
                col[i] = false;
                path.removeLast();
            }
        }
    }

    private List<String> convert2board(Deque<Integer> path) {
        List<String> board = new ArrayList<>();
        for (Integer num : path) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(".".repeat(Math.max(0, n)));
            stringBuilder.replace(num, num + 1, "Q");
            board.add(stringBuilder.toString());
        }
        return board;
    }
}
```

「回溯问题」应用于游戏，一般都比较难，大家可以根据自己的实际情况酌情选择相关的练习来做。

![image.png](https://pic.leetcode-cn.com/1601107085-lJDGur-image.png)




## 练习

1. 完成「力扣」第 52 题：[N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)；
2. 完成「力扣」第 1307 题：[口算难题](https://leetcode-cn.com/problems/verbal-arithmetic-puzzle/)；
3. 完成「力扣」24 点



51-60





# 《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 51-60 题

### 第 51 题：数组中的逆序对

传送门：[数组中的逆序对](https://www.acwing.com/problem/content/61/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)。

>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
>
>输入一个数组，求出这个数组中的逆序对的总数。
>
>样例：
>
>输入：`[1,2,3,4,5,6,0]`
>
>输出：6

专门整理成文章。1、用归并排序；2、用 BST。如何记录左子树中结点的个数。

思路1：首先我们应该想到，使用定义计算逆序数。不过时间复杂度是：$O(n^2)$。

```python
class Solution(object):
    def inversePairs(self, nums):
        l = len(nums)
        if l < 2:
            return 0
        res = 0
        for i in range(0, l - 1):
            for j in range(i + 1, l):
                if nums[i] > nums[j]:
                    res += 1
        return res
```

这种思路虽然很直接，但编写出错的概率就很低了，在没有在线评测系统的时候，它可以作为一个“正确的”参考答案，用以检验我们自己编写的算法是否正确。

思路2：借助归并排序的分治思想，时间复杂度为 $O(n \log n)$。

分析：例如：前有序数组：$[2,3,5,8]$，后有序数组：$[4,6,7,12]$。

做归并的时候，步骤如下：

第 1 步，$2$ 先出列，$2$ 比“后有序数组”中所有的元素都小，构成“顺序对”；

第 2 步，$3$ 出列，$3$ 比“后有序数组”中所有的元素都小，构成“顺序对”；

第 3 步，$4$ 出列，关键的地方在这里，**“前有序数组”中所有剩下的元素 $[5,8]$ 比 $4$  都大，构成 $2$ 个 “逆序对”**；

第 4 步，$5$ 出列，$5$ 比“后有序数组”中所有剩下的元素都小，构成“顺序对”；

第 5 步，$6$ 出列，**“前有序数组”中所有剩下的元素 $[8]$ 比 $6$ 都大，构成 $1$ 个“逆序对”**；

第 6 步，$7$ 出列，**“前有序数组”中所有剩下的元素 $[8]$ 比 $7$ 都大，构成 $1$ 个“逆序对”**；

第 7 步，$8$ 出列，$8$ 比“后有序数组”中所有剩下的元素 $[8]$ 都小，构成 $1$ 个“顺序对”；

第 8 步，$12$ 出列，此时“前有序数组”为空。

因此，我们只需要在“前有序数组”非空，且“后有序数组”中有元素出列的时候，即上面的第 3、5、6 步计算“逆序对”就可以了。

参考代码：

Python 代码：

```python
class Solution(object):
    def inversePairs1(self, nums):
        l = len(nums)
        if l < 2:
            return 0
        res = 0
        for i in range(0, l - 1):
            for j in range(i + 1, l):
                if nums[i] > nums[j]:
                    res += 1
        return res

    def inversePairs(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        l = len(nums)
        if l < 2:
            return 0
        temp = [0 for _ in range(l)]
        return self.count_inversion_pairs(nums, 0, l - 1, temp)

    def count_inversion_pairs(self, nums, l, r, temp):
        """
        在数组 nums 的区间 [l,r] 统计逆序对
        :param nums:
        :param l: 待统计数组的左边界，可以取到
        :param r: 待统计数组的右边界，可以取到
        :param temp:
        :return:
        """
        # 极端情况下，就是只有 1 个元素的时候
        if l == r:
            return 0
        mid = l + (r - l) // 2
        left_pairs = self.count_inversion_pairs(nums, l, mid, temp)
        right_pairs = self.count_inversion_pairs(nums, mid + 1, r, temp)

        merge_pairs = 0
        # 代码走到这里的时候，
        # [l, mid] 已经完成了排序并且计算好逆序对
        # [mid + 1, r] 已经完成了排序并且计算好逆序对
        # 如果 nums[mid] <= nums[mid + 1]，此时就不存在逆序对
        # 当 nums[mid] > nums[mid + 1] 的时候，就要继续计算逆序对
        if nums[mid] > nums[mid + 1]:
            # 在归并的过程中计算逆序对
            merge_pairs = self.merge_and_count(nums, l, mid, r, temp)
        # 走到这里有 nums[mid] <= nums[mid + 1] 成立，已经是顺序结构
        return left_pairs + right_pairs + merge_pairs

    def merge_and_count(self, nums, l, mid, r, temp):
        """
        前：[2,3,5,8]，后：[4,6,7,12]
        我们只需要在后面数组元素出列的时候，数一数前面这个数组还剩下多少个数字，
        因为"前"数组和"后"数组都有序，
        因此，"前"数组剩下的元素个数 mid - i + 1 就是与"后"数组元素出列的这个元素构成的逆序对个数
         
        """
        for i in range(l, r + 1):
            temp[i] = nums[i]
        i = l
        j = mid + 1
        res = 0
        for k in range(l, r + 1):
            if i > mid:
                nums[k] = temp[j]
                j += 1
            elif j > r:
                nums[k] = temp[i]
                i += 1
            elif temp[i] <= temp[j]:
                # 不统计逆序对，只做排序
                nums[k] = temp[i]
                i += 1
            else:
                assert temp[i] > temp[j]
                nums[k] = temp[j]
                j += 1
                # 快就快在这里，一次可以数出一个区间的个数的逆序对
                # 例：[7,8,9][4,6,9]，4 与 7 以及 7 前面所有的数都构成逆序对
                res += (mid - i + 1)
        return res
```

说明：归并两个有序数组的时候，我们要借助额外的辅助空间，为此可以全局使用一个和原始数组等长的辅助数组，否则每一次进入 `merge` 函数都要 new 新数组，开销很大。

上述解法的缺点是修改了原始数组，排序完成以后，逆序数就计算出来了。为此：（1）我们可以引入一个索引数组；（2）或者直接拷贝一个原始数组，这样就不用修改原始数组了。

### 第 52 题：两个链表的第一个公共结点

传送门：[两个链表的第一个公共结点](https://www.acwing.com/problem/content/62/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

>输入两个链表，找出它们的第一个公共结点。
>
>样例：
>
>给出两个链表如下所示：
>```
>A：    a1 → a2
>                   ↘
>                     c1 → c2 → c3
>                   ↗            
>B：b1 → b2 → b3
>```
>输出第一个公共节点 c1。


思路1：两个链表如果有相同起点的话就好办了，所以首先要计算出两个链表的长度，进而计算它们的差值。

Python 代码：

```python
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):

    def __get_list_node_size(self, root):
        node = root
        size = 0
        while node:
            size += 1
            node = node.next
        return size

    def findFirstCommonNode(self, headA, headB):
        """
        :type headA, headB: ListNode
        :rtype: ListNode
        """
        if headA is None or headB is None:
            return None

        s1 = self.__get_list_node_size(headA)
        s2 = self.__get_list_node_size(headB)

        # 我们默认 l1 >= l2
        h1 = headA
        h2 = headB

        if s2 > s1:
            # 如果 B 长度更长，把二者交换
            h1 = headB
            h2 = headA
        # 现在 h1 上走 (s1 - s2) 这么多长度
        for _ in range(abs(s1 - s2)):
            h1 = h1.next
        # 然后齐头并进
        while h1 and h2 and h1.val != h2.val:
            h1 = h1.next
            h2 = h2.next

        # 走到这里，如果是因为 h1 和 h2 都空了，返回 Node
        if h1 is None and h2 is None:
            return None
        else:
            return h1
```

Java 代码：
```java

class ListNode {
    int val;
    ListNode next;

    public ListNode(int val) {
        this.val = val;
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        ListNode cur = this;
        while (cur != null) {
            s.append(cur.val + " -> ");
            cur = cur.next;
        }
        s.append("NULL");
        return s.toString();
    }
}

// 第 52 题：两个链表的第 1 个公共节点 P253
// 参考资料：
// 1、https://blog.csdn.net/derrantcm/article/details/46761093
public class Solution {

    public static ListNode findFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode p1 = pHead1;
        ListNode p2 = pHead2;
        while (p1 != p2) {
            p1 = (p1 != null ? p1.next : pHead2);
            p2 = (p2 != null ? p2.next : pHead1);
        }
        return p1;
    }
}
```

思路2：用两个栈。

Python 代码：写法上要注意，不要想当然

```python
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):

    def findFirstCommonNode(self, headA, headB):
        """
        :type headA, headB: ListNode
        :rtype: ListNode
        """
        if headA is None or headB is None:
            return None
        stack1 = []
        stack2 = []
        node1 = headA
        while node1:
            stack1.append(node1)
            node1 = node1.next
        node2 = headB
        while node2:
            stack2.append(node2)
            node2 = node2.next
        # 注意：这里有陷阱，一定要先设置一个 result 结点
        # 如果两个链表没有公共元素，res 不会被赋值
        res = None
        while stack1 and stack2:
            node1 = stack1.pop()
            node2 = stack2.pop()
            if node1.val == node2.val:
                # 这里暂存一下，最后一个相等的结点才是我们求的
                res = node1
                continue
            if stack1 is None or stack2 is None:
                return None
        return res
```

思路3：拼成一样长，这个写法记住就可以了。

Python 代码：

```python
class Solution(object):

    def findFirstCommonNode(self, headA, headB):
        """
        :type headA, headB: ListNode
        :rtype: ListNode
        """
        if headA is None or headB is None:
            return None
        p1 = headA
        p2 = headB

        while p1 != p2:
            if p1 is None:
                p1 = headB
            else:
                p1 = p1.next
            if p2 is None:
                p2 = headA
            else:
                p2 = p2.next
        return p1
```

### LeetCode 第 160 题：两个单链表相交的起始节点

把不整齐的地方补整理，答案也是固定写法，多写几遍。

Python 代码：

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# 思路：两个链表不一样长，就想办法让它们一样长。

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        if headA is None or headB is None:
            return None
        node1 = headA
        node2 = headB
        while node1 != node2:
            if node1:
                node1 = node1.next
            else:
                node1 = headB
            if node2:
                node2 = node2.next
            else:
                node2 = headA
        return node1
```

### 第 53 题：数字在排序数组中出现的次数 （二分法典型问题）

传送门：[数字在排序数组中出现的次数](https://www.acwing.com/problem/content/63/)。

>统计一个数字在排序数组中出现的次数。
>
>例如输入排序数组 `[1, 2, 3, 3, 3, 3, 4, 5]` 和数字 3 ，由于 3 在这个数组中出现了 4 次，因此输出4。
>
>样例：
>
>输入：`[1, 2, 3, 3, 3, 3, 4, 5]` ,  3
>
>输出：4

参考资料：[《剑指 Offer》（第 2 版）第 53 题：数字在排序数组中出现的次数](https://www.zybuluo.com/liweiwei1419/note/1398107)。

思路1：写一个二分法，使用二分法找到大于等于 $k$ 的第 $1$ 个数的下标，再使用二分法找到大于等于 $k+1$ 的第 $1$ 个数的下标，二者之差即为所求。特别注意，这里是如何使用二分法的。

Python 代码：

```python
class Solution(object):

    # 返回大于等于 target 的第 1 个数
    def get_left(self, nums, target):
        # [2,3,4,5,5,5,5,5,5,5]
        # [1,1,1,1,1,1,1,1,1,2,3,4,5,5,5,5,5,5,5]
        if nums[0] == target:
            return 0
        l = 1
        r = len(nums)
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                assert nums[mid] >= target
                # 不能排除 mid
                r = mid
        return l

    def getNumberOfK(self, nums, k):
        """
        :type nums: list[int]
        :type k: int
        :rtype: int
        """
        size = len(nums)
        if size == 0:
            return 0

        return self.get_left(nums, k + 1) - self.get_left(nums, k)
```

严格按照二分法模板的话，代码要这样写：

Python 代码：

```python
class Solution(object):

    def getNumberOfK(self, nums, k):
        """
        :type nums: list[int]
        :type k: int
        :rtype: int
        """
        size = len(nums)
        if size == 0:
            return 0

        # 设置辅助函数，给一个 nums，一个 k，返回大于等于 k 的第一个数的索引
        return self.__helper(nums, k + 1) - self.__helper(nums, k)

    def __helper(self, nums, k):
        """
        返回大于等于 k 的第一个数的索引
        :param nums:
        :param k:
        :return:
        """
        size = len(nums)
        if size == 0:
            return 0

        l = 0
        # 注意：这里一定要写 size
        r = size - 1
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] >= k:
                r = mid
            else:
                assert nums[mid] < k
                # [1,2,3,4,5]
                l = mid + 1
        # 因为 k 有可能不存在，所以不一定符合要求，所以一定要单独判断一下
        if nums[l] != k:
            if nums[size - 1] < k:
                return size
            elif nums[0] > k:
                return 0
        return l
```

C++ 代码：

```c++
class Solution {
public:
    int getNumberOfK(vector<int>& nums , int k) {
        if (nums.empty()) return 0;
        return helper(nums, k + 1) - helper(nums, k);
    }

    int helper(vector<int>& nums, int k){
        int l = 0, r = nums.size();
        while (l < r){
            int m = l + (r - l) / 2;
            if (nums[m] < k) l = m + 1;
            else r = m;
        }
        return l;
    }
};
```

思路2：写两个二分法，一个数出现的次数，一个数最右边的索引 - 一个数最左边的索引 + 1。

```python
# # 56、数字在排序数组中出现的次数
# 统计一个数字在排序数组中出现的次数。
#
# 例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。


class Solution(object):

    def getNumberOfK(self, nums, k):
        """
        :type nums: list[int]
        :type k: int
        :rtype: int
        """
        size = len(nums)
        if size == 0:
            return 0

        # 设置辅助函数，给一个 nums，一个 k，返回大于等于 k 的第一个数的索引

        k_right = self.__get_right_k(nums, k)
        k_left = self.__get_left_k(nums, k)

        if k_right == -1 or k_left == -1:
            return 0

        return k_right - k_left + 1

    def __get_right_k(self, nums, k):
        # 找到最右边的 index ，使得 nums[index] = k
        size = len(nums)
        if size == 0:
            return -1
        l = 0
        r = size - 1
        while l < r:
            mid = l + (r - l + 1) // 2
            if nums[mid] <= k:
                # [1,2,5,5,5,7]
                l = mid
            elif nums[mid] > k:
                r = mid - 1
        if nums[l] != k:
            return -1
        return l

    def __get_left_k(self, nums, k):
        # 找到最左边的 index ，使得 nums[index] = k
        size = len(nums)
        if size == 0:
            return -1
        l = 0
        r = size - 1
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] >= k:
                r = mid
            else:
                assert nums[mid] < k
                l = mid + 1
        if nums[l] != k:
            return -1
        return l


if __name__ == '__main__':
    nums = [2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10]
    k = 5
    solution = Solution()
    # result = solution.get_left(nums, 5, )
    # print(result)

    result = solution.getNumberOfK(nums, k)
    print(result)
```

### 第 54 题：二叉搜索树的第 $k$ 大结点

传送门：[二叉搜索树的第 k 大结点](https://www.acwing.com/problem/content/66/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 给定一棵二叉搜索树，请找出其中的第 $k$ 小的结点。
>
> 你可以假设树和 $k$ 都存在，并且 1≤ k ≤ 树的总结点数。
>
> 样例：
>
> 输入：`root = [2, 1, 3, null, null, null, null]` ，`k = 3`
>
> ```
>     2
>   / \
> 1   3
> ```
>
> 输出：3

思路：使用栈模拟 BST 的中序遍历。

Python 代码：

```python
class Solution(object):
    def kthNode(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: TreeNode
        """

        if root is None:
            return None

        # 1 表示递归处理，0 表示当前我就要处理这个结点
        stack = [(1, root)]

        while stack:
            type, node = stack.pop()
            if type == 0:
                k -= 1
                if k == 0:
                    return node
            else:
                if node.right:
                    stack.append((1, node.right))
                stack.append((0, node))
                if node.left:
                    stack.append((1, node.left))
```

### 第 55-1 题：二叉树的深度

传送门：[二叉树的深度](https://www.acwing.com/problem/content/67/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。。

>输入一棵二叉树的根结点，求该树的深度。
>
>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
>
>样例：
>
>输入：二叉树 `[8, 12, 2, null, null, 6, 4, null, null, null, null]` 如下图所示：
>```
>       8
>      / \
>    12  2
>        / \
>      6   4
>```
>输出：3


思路：使用广度优先遍历。

Python 代码：

```python
class Solution:
    def treeDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """

        if root is None:
            return 0

        queue = [(1, root)]
        res = 0
        while queue:
            top = queue.pop(0)
            cur_depth, node = top[0], top[1]
            res = max(res, cur_depth)
            if node.left:
                queue.append((cur_depth + 1, node.left))
            if node.right:
                queue.append((cur_depth + 1, node.right))
        return res
```

### 第 55-2 题：平衡二叉树

传送门：[平衡二叉树](https://www.acwing.com/problem/content/68/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

>输入一棵二叉树的根结点，判断该树是不是平衡二叉树。
>
>如果某二叉树中任意结点的左右子树的深度相差不超过 $1$，那么它就是一棵平衡二叉树。
>
>**注意：**
>
>- 规定空树也是一棵平衡二叉树。
>
>样例：
>
>输入：二叉树 `[5,7,11,null,null,12,9,null,null,null,null]` 如下所示，
>```
>      5
>     / \
>    7  11
>       / \
>      12  9
>```
>输出：true


思路：深度优先遍历（**后序遍历**）。

Python 代码：

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    # 全局变量
    flag = 1

    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """

        if root is None:
            return True
        self.__dfs(root)
        return self.flag

    def __dfs(self, node):
        """
        返回以 root 为根的二叉树的高度，如果左右子树其中之一不是 AVL ，则返回 -1
        :param node:
        :return:
        """
        if node is None:
            return 0
        left = self.__dfs(node.left)
        right = self.__dfs(node.right)

        if abs(left - right) > 1:
            self.flag = 0
            # 这里不能写 return
        return max(left, right) + 1
```

Java 代码：

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

// 第 55 题：二叉树的深度（判断是不是平衡二叉树）
// 可以提交到 LeetCode 第 110 题的测试用例
// 参考资料1：
// https://blog.csdn.net/derrantcm/article/details/46771529
public class Solution {

    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        int[] depth = new int[1];
        depth[0] = 0;
        return postOrder(root, depth);
    }

    // 后序遍历
    private boolean postOrder(TreeNode node, int[] depth) {
        if (node == null) {
            depth[0] = 0;
            return true;
        }
        int[] left = new int[1];
        int[] right = new int[1];
        // 如果左子树和右子树都不是平衡二叉树，直接就走到最后，返回 false
        if (postOrder(node.left, left) && postOrder(node.right, right)) {
            int diff = left[0] - right[0];
            if (diff <= 1 && diff >= -1) {
                depth[0] = Integer.max(left[0], right[0]) + 1;
                return true;
            }
        }
        return false;
    }
}
```

### 第 56-1 题：数组中只出现一次的两个数字

传送门：[数组中只出现一次的两个数字](https://www.acwing.com/problem/content/69/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。
>
> 请写程序找出这两个只出现一次的数字。
>
> 你可以假设这两个数字一定存在。
>
> 样例：
>
> 输入：$[1,2,3,3,4,4]$
>
> 输出：$[1,2]$

思路：**按位分组**。

Python 代码：

```python
class Solution(object):
    def findNumsAppearOnce(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        l = len(nums)
        if l < 2:
            raise Exception('程序出错')
        if l == 2:
            return nums

        # 全部相与一遍
        xor = 0
        for num in nums:
            xor ^= num
            
        # 最末尾的 1 从右向左边数在第几位
        counter = 0
        while xor & 1 == 0:
            xor >>= 1
            counter += 1

        res = [0, 0]
        for num in nums:
            if (num >> counter) & 1 == 1:
                res[1] ^= num
            else:
                res[0] ^= num
        return res
```

Java 代码：

```java
import java.util.Arrays;

// 第 56 题：数组中数字出现的次数 P275
// 参考资料：
// 1、https://blog.csdn.net/derrantcm/article/details/46771717
public class Solution {

    // 考察位运算：或、与、异或、非，以及无符号左移 >>>
    public int[] findNumbersAppearanceOnce(int[] nums) {
        int len = nums.length;
        int[] res = new int[2];
        assert len >= 2;
        if (len == 2) {
            return nums;
        }
        // 那两个只出现一次的数的异或运算的结果
        int xor = xor(nums);
        
        // 关键在这里
        // 找到这个 xor 的二进制表示第 1 个是 1 的数位是第几位
        int binaryFirstNotZero = binaryFirstNotZero(xor);
        
        // 接下来分别对两组进行异或
        for (int i = 0; i < len; i++) {
            // 如果这个数右移这么多位是 1 的分在一组，是 0 的分在另外一组，遍历的时候，就进行异或运算
            if ((nums[i] >>> binaryFirstNotZero & 1) == 1) {
                res[0] ^= nums[i];
            } else {
                res[1] ^= nums[i];
            }
        }
        return res;
    }

    // 得到一个数组经过异或运算的结果 xor
    // 异或 的英文翻译就是 xor
    private int xor(int[] nums) {
        int xor = 0;
        for (int i = 0; i < nums.length; i++) {
            xor ^= nums[i];
        }
        return xor;
    }

    // 得到一个整数的二进制表示从右到左第 1 个非零的位数是第几位
    private int binaryFirstNotZero(int num) {
        int index = 0;
        // 这里的 1 把它看成二进制的 1，即 00000001
        while ((num & 1) == 0 && index < 32) {
            num >>>= 1;
            index++;
        }
        // 走到这里满足 (num & 1) == 1
        return index;
    }

    public static void main(String[] args) {
        int[] nums = {2, 4, 3, 6, 3, 2, 5, 5};
        Solution solution = new Solution();
        int[] res = solution.findNumbersAppearanceOnce(nums);
        System.out.println(Arrays.toString(res));

        int[] nums2 = {2, 4, 3, 6, 3, 2, 5, 5};
        int[] res2 = solution.findNumbersAppearanceOnce(nums2);
        System.out.println(Arrays.toString(res2));

        int[] nums3 = {4, 6};
        int[] res3 = solution.findNumbersAppearanceOnce(nums3);
        System.out.println(Arrays.toString(res3));

        int[] nums4 = {4, 6, 1, 1, 1, 1};
        int[] res4 = solution.findNumbersAppearanceOnce(nums4);
        System.out.println(Arrays.toString(res4));
    }
}
```

### 0 到 n-1 中缺失的数字

传送门：[0 到 n-1 中缺失的数字](https://www.acwing.com/problem/content/64/)。

> 一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0 到 n-1 之内。
>
> 在范围 0 到 n-1 的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。
>
> 样例
>
> ```
> 输入：[0,1,2,4]
> 
> 输出：3
> ```

思路：典型的使用“二分法”解决的问题。

Python 代码：

```python
class Solution(object):
    def getMissingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        size = len(nums)
        l = 0
        r = size

        while l < r:

            mid = l + (r - l) // 2
            if nums[mid] > mid:
                # [0,1,2,3,4,6]
                # mid 有可能是要求的数
                r = mid
            else:
                assert nums[mid] <= mid
                l = mid + 1
        return l


if __name__ == '__main__':
    solution = Solution()
    nums = [0, 1, 2, 4]
    result = solution.getMissingNumber(nums)
    print(result)
```

### 数组中数值和下标相等的元素

传送门：[数组中数值和下标相等的元素](https://www.acwing.com/problem/content/65/)。

> 假设一个单调递增的数组里的每个元素都是整数并且是唯一的。
>
> 请编程实现一个函数找出数组中任意一个数值等于其下标的元素。
>
> 例如，在数组 $[-3, -1, 1, 3, 5]$ 中，数字 $3$ 和它的下标相等。
>
> 样例：
>
> 输入：$[-3, -1, 1, 3, 5]$
>
> 输出：$3$
>
> **注意**：如果不存在，则返回 $-1$。

思路：典型的使用“二分法”解决的问题。

Python 代码：

```python
class Solution(object):
    def getNumberSameAsIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        # 使用二分法
        size = len(nums)
        l = 0
        r = size - 1

        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < mid:
                l = mid + 1
            else:
                assert nums[mid] >= mid
                r = mid
        return l if nums[l] == l else -1
```

Python 代码：

```python
class Solution(object):
    def getNumberSameAsIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        size = len(nums)
        
        if size == 0:
            return -1
            
        l = 0
        r = size - 1
        
        while l < r:
            mid = l + (r - l + 1) // 2
            
            if nums[mid] > mid:
                r = mid - 1
            else:
                l = mid
        return l if nums[l] == l else -1 
```

Python 代码：

```python
class Solution(object):
    def getNumberSameAsIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        size = len(nums)
        
        if size == 0:
            return -1
            
        l = 0
        r = size - 1
        
        while l < r:
            mid = l + (r - l + 1) // 2
            
            if nums[mid] <= mid:
                l = mid 
            else:
                r = mid - 1
        return l if nums[l] == l else -1 
```

### 第 56-2 题：数组中唯一只出现一次的数字

传送门：[数组中唯一只出现一次的数字](https://www.acwing.com/problem/content/70/)。

> 在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。
>
> 请找出那个只出现一次的数字。
>
> 你可以假设满足条件的数字一定存在。
>
> **思考题：**
>
> - 如果要求只使用 $O(n)$ 的时间和额外 $O(1)$ 的空间，该怎么做呢？
>
> 样例：
>
> ```
> 输入：[1,1,1,2,2,2,3,4,4,4]
> 
> 输出：3
> ```

思路：限制在 $O(1)$ 空间复杂度，那就只有通过二进制，一位一位去看了。

Python 代码：

```python
class Solution(object):
    def findNumberAppearingOnce(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        res = 0

        for i in range(32):
            count = 0
            for num in nums:
                # 不要忘记 & 1
                if (num >> i) & 1:
                    count += 1
            if count % 3:
                res += 1 << i
        return res


if __name__ == '__main__':
    nums = [1, 0, 0, 0, 2, 1, 1]
    solution = Solution()
    result = solution.findNumberAppearingOnce(nums)
    print(result)
```

### 第 57-1 题：和为 S 的两个数字

传送门：[AcWing：和为 S 的两个数字](https://www.acwing.com/problem/content/71/)。

> 输入一个数组和一个数字 s ，在数组中查找两个数，使得它们的和正好是 s 。
>
> 如果有多对数字的和等于 s ，输出任意一对即可。
>
> 你可以认为每组输入中都至少含有一组满足条件的输出。
>
> 样例：
>
> 输入：`[1,2,3,4]` , `sum=7`
>
> 输出：`[3,4]`

说明：同 LeetCode 第 1 题，必须要会的一题。

Python 代码：

```python
class Solution(object):
    def findNumbersWithSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        
        s = set()
        for num in nums:
            if target - num not in s:
                s.add(num)
            else:
                return [num, target - num]
```

### 第 57-2 题：和为 S 的连续正数序列

传送门：[AcWing：和为 S 的连续正数序列](https://www.acwing.com/problem/content/72/)。

> 输入一个正数 s ，打印出所有和为 s 的连续正数序列（至少含有两个数）。
>
> 例如输入$15$，由于 $1+2+3+4+5=4+5+6=7+8=15$，所以结果打印出 $3$ 个连续序列 $1～5$、$4～6$ 和 $7～8$。
>
> 样例：
>
> 输入：$15$
>
> 输出：$[[1,2,3,4,5],[4,5,6],[7,8]]$

思路：双指针，因为是有序数组，所以可以使用二分法。

设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为 $1$，最后一个数为 $2$，因为是要求是连续正数序列，最后不可能和第一个数重合。下一步就是不断改变第一个数和最后一个数的值，如果从第一个数到最后一个数的和刚好是要求的和，那么把所有的数都添加到一个序列中；如果大于要求的和，则说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加 $1$，同时把当前和减去原来的第一个数的值；如果小于要求的和，说明范围太小，因此把最后一个数加 $1$，同时把当前的和加上改变之后的最后一个数的值。这样，不断修改第一个数和最后一个数的值，就能确定所有连续正数序列的和等于 $S$ 的序列了。

等差数列求和公式，首项加末项的和乘以个数除以 $2$，即 ${\rm sum} = \cfrac {(a + b)\times n }{2}$。

注意：右边界问题，使用一个特例，例如 $3$ 就可以考虑清楚了。

Python 代码：

```python
class Solution(object):
    def findContinuousSequence(self, sum):
        """
        :type sum: int
        :rtype: List[List[int]]
        """

        res = []

        left = 1
        right = 2

        # sum = 3 的时候，右边界最多到 2
        half = sum // 2 + 1
        while left < right <= half:
            cur_sum = (left + right) * (right - left + 1) // 2
            if cur_sum == sum:
                res.append([i for i in range(left, right + 1)])
                right += 1
            elif cur_sum < sum:
                right += 1
            else:
                assert cur_sum > sum
                left += 1
        return res


if __name__ == '__main__':
    sum = 15
    solution = Solution()
    result = solution.findContinuousSequence(sum)
    print(result)
```

### 第 58-1 题：翻转单词顺序列

传送门：[AcWing：翻转单词顺序](https://www.acwing.com/problem/content/73/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。
>
> 为简单起见，标点符号和普通字母一样处理。
>
> 例如输入字符串`"I am a student."`，则输出`"student. a am I"`。
>
> 样例：
>
> 输入：`"I am a student."`
>
> 输出：`"student. a am I"`

思路：实现一个辅助的方法，将一个字符数组的指定区间进行翻转。

Python 代码：

```python
class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """

        size = len(s)
        arr = list(s)

        self.__reverse(arr, 0, size - 1)

        begin = 0
        index = 0
        while index < size:
            if arr[index] == ' ':
                self.__reverse(arr, begin, index - 1)
                begin = index + 1
            index += 1
        # 最后还要反转一下
        self.__reverse(arr, begin, size - 1)
        return ''.join(arr)

    def __reverse(self, arr, left, right):
        if left >= right:
            return
        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
```

Java 代码：

```java
public class Solution {

    /**
     * 辅助函数：翻转字符数组指定区间内的字符
     *
     * @param str
     * @param start
     * @param end
     */
    private void reverseString(char[] str, int start, int end) {
        int l = start;
        int r = end;
        while (l < r) {
            swap(str, l, r);
            l++;
            r--;
        }
    }

    /**
     * 辅助函数：交换字符数组指定索引的字符
     *
     * @param str
     * @param index1
     * @param index2
     */
    private void swap(char[] str, int index1, int index2) {
        if (index1 == index2) {
            return;
        }
        char temp = str[index1];
        str[index1] = str[index2];
        str[index2] = temp;
    }

    public String ReverseSentence(String str) {
        int len = str.length();
        if (len == 0 || len == 1) {
            return str;
        }
        char[] charArr = str.toCharArray();
        reverseString(charArr, 0, len - 1);
        int start = 0;
        for (int i = 0; i < len; i++) {
            if (charArr[i] == ' ') {
                reverseString(charArr, start, i - 1);
                start = i + 1;
            }
        }
        // 最后还要记得反转一下
        reverseString(charArr, start, len - 1);
        return String.valueOf(charArr);
    }

    public static void main(String[] args) {
        String str = "write your code here";
        Solution solution = new Solution();
        String reverseSentence = solution.ReverseSentence(str);
        System.out.println(reverseSentence);
    }
}
```

总结：别把问题想复杂了，有点耐心，这些问题其实并没有那么难。

### 第 58-2 题：左旋转字符串

传送门：[左旋转字符串](https://www.acwing.com/problem/content/74/)，[牛客网 online judge 地址](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)。

> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
>
> 请定义一个函数实现字符串左旋转操作的功能。
>
> 比如输入字符串`"abcdefg"`和数字2，该函数将返回左旋转2位得到的结果`"cdefgab"`。
>
> **注意：**
>
> - 数据保证n小于等于输入字符串的长度。
>
> 样例
>
> ```
> 输入："abcdefg" , n=2
> 
> 输出："cdefgab"
> ```

思路：“abcdefg” 旋转以后，“gfedcba”，在倒数第 2 位前后，再翻转一下，得“cdefgab”。左旋转字符串的时候要分析清楚，注意：移动的位数要取余数。

Python 代码：

```python
class Solution(object):
    def leftRotateString(self, s, n):
        """
        :type s: str
        :type n: int
        :rtype: str
        """

        size = len(s)
        # 特判
        if size == 0 or n % size == 0:
            return s
        n = n % size
        arr = list(s)
        self.__reverse(arr, 0, size - 1)

        self.__reverse(arr, 0, size - 1 - n)
        self.__reverse(arr, size - n, size - 1)

        return ''.join(arr)

    def __reverse(self, arr, left, right):
        if left >= right:
            return
        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
```

Java 代码：
```java
public class Solution {

    private void reverseString(char[] charArr, int start, int end) {
        int l = start;
        int r = end;
        while (l < r) {
            swap(charArr, l, r);
            l++;
            r--;
        }
    }

    private void swap(char[] charArr, int index1, int index2) {
        if (index1 == index2) {
            return;
        }
        char temp = charArr[index1];
        charArr[index1] = charArr[index2];
        charArr[index2] = temp;
    }

    public String LeftRotateString(String str, int n) {
        int len = str.length();
        if (len == 0 || n < 0) {
            return "";
        }
        if (len == 1) {
            return str;
        }

        // 这里要注意了
        n = len - n % len;

        char[] charArr = str.toCharArray();
        reverseString(charArr, 0, len - 1);
        reverseString(charArr, 0, n - 1);
        reverseString(charArr, n, len - 1);
        return String.valueOf(charArr);
    }

    public static void main(String[] args) {
        String str = "abcXYZdef";
        Solution solution = new Solution();
        String leftRotateString = solution.LeftRotateString(str, 3);
        System.out.println(leftRotateString);
    }
}
```

### 第 59 题：滑动窗口的最大值（典型问题）

传送门：[滑动窗口的最大值](https://www.acwing.com/problem/content/75/)。

> 给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。
>
> 例如，如果输入数组 `[2, 3, 4, 2, 6, 2, 5, 1]` 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，它们的最大值分别为 `[4, 4, 6, 6, 6, 5]`。
>
> **注意：**
>
> - 数据保证 $k$ 大于 $0$ ，且 $k$ 小于等于数组长度。
>
> 样例：
>
> 输入：`[2, 3, 4, 2, 6, 2, 5, 1]` , `k=3`
>
> 输出： `[4, 4, 6, 6, 6, 5]`

同 LeetCode 第 239 题，传送门：[LeetCode 第 239 题：滑动窗口的最大值](https://www.zybuluo.com/liweiwei1419/note/1394373)。

Python 代码：`window[0] == i - k` 这个条件特别容易忽略，表示确实该被移出滑动窗口

```python
class Solution:
    def maxSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """

        # 关键：如果后进来一个数，前面的元素比它小
        # 那么前面的元素就永远不可能是"滑动窗口中的最大值"

        l = len(nums)
        if l == 0 or k <= 0:
            return []

        res = []
        window = []
        for i in range(l):

            # 考虑什么时候，要把最大移除
            # 左边界划出的时候，应该是 window.pop(0)
            # [0,1,2,3,4]
            #     [    i]
            # window[0] == i - k 这个条件特别容易忽略
            if i >= k and window[0] == i - k:
                window.pop(0)
            # 考虑把不可能是最大的元素全部 kill 掉
            while window and nums[i] >= nums[window[-1]]:
                window.pop()
            # 不管怎么着都加当前的索引
            window.append(i)

            # 什么时候有滑动窗口呢？
            if i >= k - 1:
                res.append(nums[window[0]])
        return res


if __name__ == '__main__':
    nums = [1, 3, -1, -3, 5, 3, 6, 7]
    k = 3

    solution = Solution()
    result = solution.maxSlidingWindow(nums, k)
    print(result)
```

### 第 60 题：$n$ 个骰子的点数（典型动态规划问题）

传送门：[AcWing：骰子的点数](https://www.acwing.com/problem/content/76/)。

> 将一个骰子投掷 $n$ 次，获得的总点数为 $s$ ，$s$ 的可能范围为 $n$ ~ $6n$。
>
> 掷出某一点数，可能有多种掷法，例如投掷 $2$ 次，掷出 $3$ 点，共有 $[1,2]$，$[2,1]$ 两种掷法。
>
> 请求出投掷 $n$ 次，掷出 $n$ ~ $6n$ 点分别有多少种掷法。
>
> 样例1：
>
> 输入：`n=1`
>
> 输出：`[1, 1, 1, 1, 1, 1]`
>
> 解释：投掷 1 次，可能出现的点数为 1-6 ，共计 6 种。每种点数都只有 1 种掷法。所以输出 `[1, 1, 1, 1, 1, 1]`。
>
> 样例2：
>
> 输入：n=2
>
> 输出：`[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]`
>
> 解释：投掷 2 次，可能出现的点数为 2-12，共计 11 种。每种点数可能掷法数目分别为 `1,2,3,4,5,6,5,4,3,2,1`。所以输出 `[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]`。

思路：典型动态规划问题。定义状态 `dp[i][j]` 表示用 `i` 个骰子扔出和为 `j` 的可能数，因为第 `i` 个骰子可能扔出 `1-6` 的点数。根据此写出状态转移方程：
$$
dp[i][j]=dp[i-1][j-1]+dp[i-1][j-2]+dp[i-1][j-3]+dp[i-1][j-4]+dp[i-1][j-5]+dp[i-1][j-6]
$$
由于我们只需要用到最后一次的结果，因此为了节省空间可以使用滚动数组，将二维 `dp` 数组变为一维。

时间复杂度分析：$O(n^2)$。

Python 代码：

```python
class Solution(object):
    def numberOfDice(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        dp = [0 for _ in range(6 * n + 1)]

        # 动归数组初始值，表示 1 个骰子扔出 1-6 的可能数都为 1
        for i in range(1, 7):
            dp[i] = 1
        # 表示仍第 2 个骰子到第 n 个骰子
        for i in range(2, n + 1):
            # 从后向前写
            for j in range(6 * i, -1, -1):
                dp[j] = 0
                # 最后一个骰子可以扔 1 - 6 点
                for k in range(6, 0, -1):
                    if j - k < 0:
                        continue
                    dp[j] += dp[j - k]
        # 扔 n 个骰子的和为 [n, 6 * n]
        return dp[n:]
```

作者：cornerCao
链接：https://www.acwing.com/solution/acwing/content/852/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

（本节完）