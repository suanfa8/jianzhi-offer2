<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 21-30 题 - 《剑指 Offer》（第 2 版）</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u300a\u5251\u6307 Offer\u300b\uff08\u7b2c 2 \u7248\uff09 \u9898\u89e3\uff08Python \u8bed\u8a00\u5b9e\u73b0\uff09\u7b2c 21-30 \u9898";
    var mkdocs_page_input_path = "21-30.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> 《剑指 Offer》（第 2 版）</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">首页</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 1 - 20 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../03/">剑指 Offer 03. 数组中重复的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../04/">剑指 Offer 04. 二维数组中的查找</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../05/">剑指 Offer 05. 替换空格</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../06/">剑指 Offer 06. 从尾到头打印链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../07/">剑指 Offer 07. 重建二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../08/">剑指 Offer 08. 二叉树的下一个结点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../09/">剑指 Offer 09. 用两个栈实现队列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../10-1/">剑指 Offer 10- I. 斐波那契数列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../10-2/">剑指 Offer 10- II. 青蛙跳台阶问题</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../11/">剑指 Offer 11. 旋转数组的最小数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../12/">剑指 Offer 12. 矩阵中的路径</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../13/">剑指 Offer 13. 机器人的运动范围</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../14-1/">剑指 Offer 14- I. 剪绳子</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../14-2/">剑指 Offer 14- II. 剪绳子 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../15/">剑指 Offer 15. 二进制中1的个数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../16/">剑指 Offer 16. 数值的整数次方</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../17/">剑指 Offer 17. 打印从1到最大的n位数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../18/">剑指 Offer 18. 删除链表的节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../19/">剑指 Offer 19. 正则表达式匹配</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../20/">剑指 Offer 20. 表示数值的字符串</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 21 - 40 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../21/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../22/">剑指 Offer 22. 链表中倒数第k个节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../24/">剑指 Offer 24. 反转链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../25/">剑指 Offer 25. 合并两个排序的链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../26/">剑指 Offer 26. 树的子结构</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../27/">剑指 Offer 27. 二叉树的镜像</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../28/">剑指 Offer 28. 对称的二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../29/">剑指 Offer 29. 顺时针打印矩阵</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../30/">剑指 Offer 30. 包含min函数的栈</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../31/">剑指 Offer 31. 栈的压入、弹出序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-1/">剑指 Offer 32 - I. 从上到下打印二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-2/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-3/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../33/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../34/">剑指 Offer 34. 二叉树中和为某一值的路径</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../35/">剑指 Offer 35. 复杂链表的复制</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../36/">剑指 Offer 36. 二叉搜索树与双向链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../37/">剑指 Offer 37. 序列化二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../38/">剑指 Offer 38. 字符串的排列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../39/">剑指 Offer 39. 数组中出现次数超过一半的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../40/">剑指 Offer 40. 最小的k个数</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 41 - 60 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../41/">剑指 Offer 41. 数据流中的中位数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../42/">剑指 Offer 42. 连续子数组的最大和</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../43/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../44/">剑指 Offer 44. 数字序列中某一位的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../45/">剑指 Offer 45. 把数组排成最小的数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../46/">剑指 Offer 46. 把数字翻译成字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../47/">剑指 Offer 47. 礼物的最大价值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../48/">剑指 Offer 48. 最长不含重复字符的子字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../49/">剑指 Offer 49. 丑数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../50/">剑指 Offer 50. 第一个只出现一次的字符</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../51/">剑指 Offer 51. 数组中的逆序对</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../52/">剑指 Offer 52. 两个链表的第一个公共节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../53/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../53-2/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../54/">剑指 Offer 54. 二叉搜索树的第k大节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../55/">剑指 Offer 55 - I. 二叉树的深度</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../55-2/">剑指 Offer 55 - II. 平衡二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../56/">剑指 Offer 56 - I. 数组中数字出现的次数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../56-2/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../57/">剑指 Offer 57. 和为s的两个数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../57-2/">剑指 Offer 57 - II. 和为s的连续正数序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../58/">剑指 Offer 58 - I. 翻转单词顺序</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../58-2/">剑指 Offer 58 - II. 左旋转字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../59/">剑指 Offer 59 - I. 滑动窗口的最大值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../59-2/">剑指 Offer 59 - II. 队列的最大值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../60/">剑指 Offer 60. n个骰子的点数</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 61 - 68 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../61/">剑指 Offer 61. 扑克牌中的顺子</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../62/">剑指 Offer 62. 圆圈中最后剩下的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../63/">剑指 Offer 63. 股票的最大利润</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../64/">剑指 Offer 64. 求1+2+…+n</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../65/">剑指 Offer 65. 不用加减乘除做加法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../66/">剑指 Offer 66. 构建乘积数组</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../67/">剑指 Offer 67. 把字符串转换成整数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../68/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../68-2/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">《剑指 Offer》（第 2 版）</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 21-30 题</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="offer-2-python-21-30">《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 21-30 题</h1>
<h3 id="21">第 21 题：调整数组使得奇数位于偶数之前</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/30/">AcWing：调整数组顺序使奇数位于偶数前面</a>，<a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序。</p>
<p>使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<p>样例：</p>
<p>输入：<code>[1,2,3,4,5]</code></p>
<p>输出： <code>[1,3,5,2,4]</code></p>
</blockquote>
<p>分析：这道题要注意的一点就是：保持原来的顺序，具体可以参考 LeetCode 第 88 题的策略，从后向前重新为数组赋值。</p>
<p>思路1：有点类似“两路快排”的思路。“两路快排”中有一些细节需要复习一下。双指针扫描：用两个指针分别从首尾开始，往中间扫描。扫描时保证<strong>第一个指针前面的数都是奇数，第二个指针后面的数都是偶数</strong>。每次迭代时需要进行的操作：</p>
<p>1、第一个指针一直往后走，直到遇到第一个偶数为止；
2、第二个指针一直往前走，直到遇到第一个奇数为止。
交换两个指针指向的位置上的数，再进入下一层迭代，直到两个指针相遇为止。
时间复杂度：当两个指针相遇时，走过的总路程长度是 $n$，所以时间复杂度是 $O(n)$。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution(object):
    def reOrderArray(self, array):
        &quot;&quot;&quot;
        :type array: List[int]
        :rtype: void
        &quot;&quot;&quot;
        # 特判
        size = len(array)
        if size &lt; 2:
            return

        l = 0
        r = size - 1

        # 始终保持 [0,l) 是奇数
        # (r,size-1] 是偶数

        while True:
            while l &lt;= r and array[l] &amp; 1 == 1:
                l += 1
            # 此时 l 来到了第一个偶数位置
            while r &gt;= l and array[r] &amp; 1 == 0:
                r -= 1
            # 此时 r 来到了第一个奇数的位置

            # 这里一定是大于号，否则数组下标会越界
            # 一定要特别注意，写 == 号会出错，写 &gt;= 是可以的，因为 == 成立的时候，不用交换
            if l &gt; r:
                break
            array[l], array[r] = array[r], array[l]
            l += 1
            r -= 1
        return array
</code></pre>
<p>C++ 代码：</p>
<p><img alt="image-20190108005607547" src="http://upload-images.jianshu.io/upload_images/414598-fd408352e8b6ff9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>C++ 代码：</p>
<pre><code class="language-c++">class Solution {
public:
    void reOrderArray(vector&lt;int&gt; &amp;array) {
         int l = 0, r = array.size() - 1;
         while (l &lt;= r) {
             while (array[l] % 2 == 1) l ++ ;
             while (array[r] % 2 == 0) r -- ;
             if (l &lt; r) swap(array[l], array[r]);
         }
    }
};
</code></pre>
<p>思路2：把奇数数组复制出来，按照从后向前归并排序的做法完成。</p>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    // 保证奇数和奇数，偶数和偶数之间的相对位置不变。
    public void reOrderArray(int[] array) {
        int len = array.length;
        if (len == 0) {
            return;
        }
        // 奇数全部挪到缓存数组中
        int[] buff = new int[len];
        int j = -1;
        for (int i = 0; i &lt; len; i++) {
            if (array[i] % 2 == 1) {
                j++;
                buff[j] = array[i];
            }
        }
        // 如果都没有奇数的话，程序终止
        if (j == -1) {
            return;
        }
        // 把偶数集中“挤”到数组的末尾
        // 然后再把缓存数组中的奇数倒序放入
        int k = len - 1;
        for (int i = len - 1; i &gt;= 0; i--) {
            if (array[i] % 2 == 0) {
                array[k] = array[i];
                k--;
            }
        }
        while (j &gt;= 0) {
            array[j] = buff[j];
            j--;
        }
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        Solution solution = new Solution();
        solution.reOrderArray(arr);
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    // 保证奇数和奇数，偶数和偶数之间的相对位置不变。
    public void reOrderArray(int[] array) {
        int len = array.length;
        if (len == 0) {
            return;
        }
        // 奇数全部挪到缓存数组中
        int[] buff = new int[len];
        int j = -1;
        for (int i = 0; i &lt; len; i++) {
            if (array[i] % 2 == 1) {
                j++;
                buff[j] = array[i];
            }
        }
        // 如果没有奇数，直接返回就可以了
        if (j == -1) {
            return;
        }
        // 从后向前赋值
        int k = len - 1;
        for (int i = len - 1; i &gt;= 0; i--) {
            if (array[i] % 2 == 0) {
                array[k] = array[i];
                k--;
            }
        }
        while (j &gt;= 0) {
            array[j] = buff[j];
            j--;
        }
    }
}
</code></pre>
<p>扩展：书本上有这个问题更一般的做法。</p>
<h3 id="22-k">第 22 题：输入一个链表，输出该链表中倒数第 k 个结点</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/32/">AcWing：链表中倒数第 k 个节点</a>，<a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一个链表，输出该链表中倒数第 k 个结点。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>k &gt;= 0</code>;</li>
<li>如果 k 大于链表长度，则返回 NULL;</li>
</ul>
<p>样例：</p>
<p>输入：链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>，<code>k=2</code></p>
<p>输出：4</p>
</blockquote>
<p>分析：设置快慢指针，思路很简单，不过在具体编码的时候，还是有一些细节要注意的，特别是空指针的判断上。</p>
<ul>
<li>因为第 k 个结点很可能是链表的第 1 个结点，因此设置虚拟头结点，是这一列问题的基本做法，可以减少分类讨论的情况。</li>
<li>对一些极端情况的讨论（下面代码中的注意点 2 ）。</li>
</ul>
<p>思路1：先遍历完，数出链表有多少个结点。</p>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def findKthToTail(self, pListHead, k):
        &quot;&quot;&quot;
        :type pListHead: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        if pListHead is None:
            return None
        counter = 0
        p = pListHead
        while p:
            counter += 1
            p = p.next
        if k &gt; counter:
            return None
        p = pListHead
        for _ in range(counter - k):
            p = p.next
        return p
</code></pre>
<p>思路2：推荐，设置快慢指针，快指针先走 $k-1$ 步，然后快慢指针一起走。</p>
<p>C++ 代码：</p>
<p><img alt="image-20190108005842835" src="http://upload-images.jianshu.io/upload_images/414598-a2acd82572754d85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def findKthToTail(self, pListHead, k):
        &quot;&quot;&quot;
        :type pListHead: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        if pListHead is None:
            return None
        fast = pListHead
        # 要注意的临界点1：
        for _ in range(k - 1):
            fast = fast.next
            # 注意判断
            if fast is None:
                return None
        slow = pListHead
        # 要注意的临界点2：
        while fast.next:
            slow = slow.next
            fast = fast.next
        return slow
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}

public class Solution {

    public ListNode FindKthToTail(ListNode head, int k) {
        // 注意点1：极端输入，直接输出结果
        if (head == null) {
            return null;
        }
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;
        ListNode fast = dummyNode;
        for (int i = 0; i &lt; k; i++) {
            fast = fast.next;
            // 注意点2：对不符合要求的输入的判断
            if (fast == null) {
                return null;
            }
        }
        ListNode slow = dummyNode;
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
</code></pre>
<h3 id="23">第 23 题：链表中环的入口结点</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/86/">AcWing：链表中环的入口结点</a>，<a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>给定一个链表，若其中包含环，则输出环的入口节点。</p>
<p>若其中不包含环，则输出<code>null</code>。</p>
<p>样例：</p>
<p><img alt="image" src="http://upload-images.jianshu.io/upload_images/414598-a1fd3c7e0fe733b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>给定如上所示的链表：<code>[1, 2, 3, 4, 5, 6]</code>，编号：2。
注意，这里的 2 表示编号是 2 的节点，节点编号从 0 开始。所以编号是 2 的节点就是 val 等于 3 的节点。</p>
<p>则输出环的入口节点 3 。</p>
</blockquote>
<p>分析：看的答案，记住结论就好，编码上还是要注意特判的情况，还有空指针的情况。“慢”指针进入环的时候，“快指针”要来追它，因为快慢指针走的步数差是固定的。例如： A 手上有 100 块钱，A 每天赚 10 块钱，B 手上有 50 块钱，B 每天赚 20，一定有一天，你们的钱相等，而且只要环内结点个数这么多就可以了。</p>
<p><img alt="image-20190110151143523" src="http://upload-images.jianshu.io/upload_images/414598-0f7504b8155657a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>我写的错误解：</p>
<p><img alt="image-20190109132103035" src="http://upload-images.jianshu.io/upload_images/414598-dfba314018602917.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<pre><code class="language-python"># 34. 链表中环的入口结点
# 给定一个链表，若其中包含环，则输出环的入口节点。
#
# 若其中不包含环，则输出null。

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def entryNodeOfLoop(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # 先考虑边界情况
        if head is None or head.next is None:
            return None

        slow = head
        fast = head

        while fast and fast.next:
            # 慢指针走一步，快指针走两步
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                # 说明链表中存在环
                break

        # 注意：跳出循环的原因有两个，有可能是根本没有环，即上面  while fast and fast.next 不成立
        # 也有可能是 slow == fast 里 break 的，分别讨论就可以了
        if fast is None or fast.next is None:
            return None

        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        # 走到这里，说明 slow == fast
        return slow
</code></pre>
<h3 id="24">第 24 题：输入一个链表，反转链表后，输出链表的所有元素</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/33/">AcWing：反转链表</a>，<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p>样例：</p>
<p>输入：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code></p>
<p>输出：<code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></p>
</blockquote>
<p>分析：这道题同 LeetCode 上一道问题，可以使用“穿针引线”也可以使用递归求解。个人觉得递归的方式比较简单，但是在链表较长的时候，递归效率偏低，因为要使用系统栈。</p>
<p>思路1：递归。</p>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# 递归写法：用递归就不用思考穿针引线这种事情了。


class Solution:
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # 递归的终止条件一定要写对：考虑结点为空和单结点的情况
        if head is None or head.next is None:
            return head
        next = head.next
        new_head = self.reverseList(next)
        next.next = head
        head.next = None
        return new_head
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}

public class Solution {

    // 递归写法要画个图就清楚了
    public ListNode ReverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode next = head.next;
        ListNode newHead = ReverseList(next);
        next.next = head;
        head.next = null;
        return newHead;
    }

}
</code></pre>
<p>思路2：非递归写法，穿针引线。</p>
<p><img alt="《剑指 Offer》（第 2 版）第 24 题：反转链表" src="http://upload-images.jianshu.io/upload_images/414598-5c6af33f6a632c55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# 穿针引线，可以看到 while 循环体部分的代码是首尾相连的，有些单链表的题目也有这种规律，感觉很神奇
# 在 Python 中，其实还有更简便的写法，就跟斐波拉契数列一样


class Solution:
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;

        pre = None
        cur = head
        while cur:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        return pre
</code></pre>
<h3 id="25">第 25 题：合并排序的链表</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/34/">AcWing：合并两个排序的链表</a>，<a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>样例：</p>
<p>输入：<code>1-&gt;3-&gt;5</code> , <code>2-&gt;4-&gt;5</code></p>
<p>输出：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5</code></p>
</blockquote>
<p>分析：同 LeetCode 第 21 题，传送门：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/">21. 合并两个有序链表</a>。这是一道经典的问题，可以使用“穿针引线”，也可以使用递归求解，个人觉得递归的代码比较简洁易懂。“穿针引线”则要画图。</p>
<p>思路1： 使用递归，编码简单。</p>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution(object):
    def merge(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;

        if l1 is None:
            return l2
        if l2 is None:
            return l1

        # 代码能走到这里说明 l1 和 l2 均非空
        # 比较哪个小就行了
        if l1.val &lt; l2.val:
            l1.next = self.merge(l1.next, l2)
            return l1
        # 走到这里 l1.val &gt;= l2.val
        l2.next = self.merge(l1, l2.next)
        return l2
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}

public class Solution {
    public ListNode Merge(ListNode list1, ListNode list2) {
        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }
        if (list1.val &lt; list2.val) {
            list1.next = Merge(list1.next, list2);
            return list1;
        } else {
            list2.next = Merge(list1, list2.next);
            return list2;
        }
    }
}
</code></pre>
<p>思路2：穿针引线。</p>
<p><img alt="《剑指 Offer （第 2 版）》第 25 题：合并两个排序的链表-1" src="http://upload-images.jianshu.io/upload_images/414598-22b6d8c06ffef176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img alt="《剑指 Offer （第 2 版）》第 25 题：合并两个排序的链表-2" src="http://upload-images.jianshu.io/upload_images/414598-96261cfbaebed718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


# 穿针引线的写法，一定要画图才能写出来
# 比较麻烦，还是递归处理简单

class Solution(object):
    def merge(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # 引入头结点可以简化对问题的讨论
        dummy_node = ListNode(-1)
        cur_node = dummy_node
        p1 = l1
        p2 = l2

        while p1 and p2:
            # 两者都不为空，才须要比较
            # 其中有一个为空的时候，把其中一个接到另一个尾巴就好了
            if p1.val &lt; p2.val:
                # next 指针修改
                cur_node.next = p1
                # p1 后移
                p1 = p1.next
            else:
                cur_node.next = p2
                p2 = p2.next
            cur_node = cur_node.next
        # 跳出循环的时候，一定有：p1 为空或者 p2 为空
        # 其中有一个为空的时候，把其中一个接到另一个尾巴就好了
        if p1 is None:  # 这一句写成 if not p1 也是可以的，不过不好理解
            cur_node.next = p2
        if not p2:
            cur_node.next = p1
        return dummy_node.next
</code></pre>
<h3 id="26-a-b-b-a">第 26 题：输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/35/">树的子结构</a>。</p>
<blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。</p>
<p>我们规定空树不是任何树的子结构。</p>
<p>样例：</p>
<p>树 A ：</p>
<p><code>8
      / \
     8   7
   / \
 9   2
      / \
     4   7</code></p>
<p>树 B ：</p>
<p><code>8
   / \
 9   2</code></p>
<p>返回 <strong>true</strong> ，因为 B 是 A 的子结构。</p>
</blockquote>
<p>思路：典型使用递归解决的问题。</p>
<p>Python 代码：在理解的基础上，记住这个题的解法</p>
<pre><code class="language-python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        # pRoot1 是大树
        # pRoot2 是小树
        result = False
        if pRoot1 and pRoot2:
            # 第 1 步：在树 A 中查找与根结点的值一样的结点
            # 这里排除了 pRoot2 是空树的情况
            if pRoot1.val == pRoot2.val:
                # 判断树 1 是不是包含树 2
                result = self.__doesTree1HaveTree2(pRoot1, pRoot2)
            if not result:
                # 如果树 1 不包含树 2
                return self.HasSubtree(pRoot1.left, pRoot2) 
                        or self.HasSubtree(pRoot1.right, pRoot2)
        return result

    def __doesTree1HaveTree2(self, pRoot1, pRoot2):
        if pRoot2 is None:
            return True
        if pRoot1 is None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        # 走到这里说明 assert pRoot1.val == pRoot2.val 为 True
        return self.__doesTree1HaveTree2(pRoot1.left, pRoot2.left) 
                and self.__doesTree1HaveTree2(pRoot1.right, pRoot2.right)
</code></pre>
<h3 id="27">第 27 题：操作给定的二叉树，将其变换为源二叉树的镜像</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/37/">二叉树的镜像</a>，<a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一个二叉树，将它变换为它的镜像。</p>
<p>样例：</p>
<p>输入树：
<code>8
   / \
  6  10
 / \ / \
5  7 9 11</code></p>
<p><code>[8,6,10,5,7,9,11,null,null,null,null,null,null,null,null]</code>
输出树：</p>
<p><code>8
   / \
  10  6
 / \ / \
11 9 7  5</code>
<code>[8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]</code></p>
</blockquote>
<p>分析：这道题的解决实际上考察了二叉树的遍历，事实上，前序遍历、后序遍历、层序遍历都是可以完成题目要求的。</p>
<p>思路1：递归方式：前序遍历或者后序遍历都行。</p>
<p>Python 代码：前序遍历</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def mirror(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: void
        &quot;&quot;&quot;
        # 先写递归终止条件
        if root is None:
            return root

        # 按照前序遍历的方式
        root.left, root.right = root.right, root.left
        self.mirror(root.left)
        self.mirror(root.right)
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }
}

public class Solution {

    // 前序遍历和后序遍历都是可以的
    public void Mirror(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        Mirror(root.left);
        Mirror(root.right);
    }

    public void Mirror1(TreeNode root) {
        if (root == null) {
            return;
        }
        Mirror(root.left);
        Mirror(root.right);
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
</code></pre>
<p>Python 代码：后序遍历</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def mirror(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: void
        &quot;&quot;&quot;
        # 先写递归终止条件
        if root is None:
            return root

        # 按照后序遍历的方式
        self.mirror(root.left)
        self.mirror(root.right)
        root.left, root.right = root.right, root.left
</code></pre>
<p>Python 代码：层序遍历</p>
<pre><code class="language-python">class Solution(object):
    def mirror(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: void
        &quot;&quot;&quot;
        # 先写递归终止条件
        if root is None:
            return root
        queue = [root]
        while queue:
            top = queue.pop(0)
            top.left, top.right = top.right, top.left
            if top.left:
                queue.append(top.left)
            if top.right:
                queue.append(top.right)
        return root
</code></pre>
<p>思路2：非递归方式（没有看出来是那种递归方式）。</p>
<p>Java 代码：</p>
<pre><code class="language-java">class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}

public class Solution {

    // 前序遍历和后序遍历都是可以的
    public void Mirror(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        Mirror(root.left);
        Mirror(root.right);
    }

    public void Mirror1(TreeNode root) {
        if (root == null) {
            return;
        }
        Mirror(root.left);
        Mirror(root.right);
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
</code></pre>
<p>非递归方式：下面这个代码有点意思。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:

    def Mirror(self, root):
        if root is None:
            return
        stack = []
        while root or stack:
            while root:
                root.left, root.right = root.right, root.left
                stack.append(root)
                root = root.left
            if stack:
                root = stack.pop()
                root = root.right
</code></pre>
<h3 id="28">第 28 题：对称的二叉树</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/38/">对称的二叉树</a>，<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p>
<p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>样例：</p>
<p>如下图所示二叉树 <code>[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]</code> 为对称二叉树：
<code>1
      / \
    2   2
  / \ / \
3  4 4  3</code>
如下图所示二叉树 <code>[1,2,2,null,4,4,3,null,null,null,null,null,null]</code> 不是对称二叉树：
<code>1
      / \
    2   2
      \ / \
      4 4  3</code></p>
</blockquote>
<p>分析：LeetCode 上有类似的问题，使用双端队列可以完成，画图画到第 4 层就非常清晰了。</p>
<p><img alt="《剑指 Offer （第 2 版）》第 28 题：对称的二叉树-1" src="http://upload-images.jianshu.io/upload_images/414598-a9a9a131ace0226e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>同 LeetCode 第  101 题。</p>
<p>解法1：递归写法。</p>
<p>Java 代码：</p>
<pre><code class="language-java">class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }
}

public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        if (pRoot == null) {
            return true;
        }
        return helper(pRoot.left, pRoot.right);
    }

    private boolean helper(TreeNode pRoot1, TreeNode pRoot2) {
        if (pRoot1 == null &amp;&amp; pRoot2 == null) {
            return true;
        }
        if (pRoot1 == null || pRoot2 == null || pRoot1.val != pRoot2.val) {
            return false;
        }
        return helper(pRoot1.left, pRoot2.right) &amp;&amp; helper(pRoot1.right, pRoot2.left);
    }
}
</code></pre>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# 递归写法：得引入辅助函数

class Solution(object):
    def isSymmetric(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: bool
        &quot;&quot;&quot;
        # 先写递归终止条件
        if root is None:
            return True
        return self.__helper(root.left, root.right)

    def __helper(self, p1, p2):
        if p1 is None and p2 is None:
            return True
        if p1 is None or p2 is None:
            return False
        return p1.val == p2.val and self.__helper(p1.left, p2.right) and self.__helper(p1.right, p2.left)
</code></pre>
<p>解法2：非递归写法，借助双端队列辅助判断。自己画一个图，就好理解了。</p>
<p><img alt="《剑指 Offer （第 2 版）》第 28 题：对称的二叉树-2" src="http://upload-images.jianshu.io/upload_images/414598-8c228afcf859232e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<pre><code class="language-python"># Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# 非递归写法：借助双端队列辅助判断

class Solution(object):
    def isSymmetric(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: bool
        &quot;&quot;&quot;
        # 先写递归终止条件
        if root is None:
            return True

        # 其实应该用 from collections import deque
        deque = []

        deque.insert(0, root.left)
        deque.append(root.right)

        while deque:
            l_node = deque.pop(0)
            r_node = deque.pop()

            # 这一步一定不要忘记了
            if l_node is None and r_node is None:
                continue
            if l_node is None or r_node is None:
                return False
            # 代码走到这里一定有 l_node 和 r_node 非空
            # 因此可以取出 val 进行判断了
            if l_node.val != r_node.val:
                return False
            deque.insert(0, l_node.right)
            deque.insert(0, l_node.left)
            deque.append(r_node.left)
            deque.append(r_node.right)
        return True
</code></pre>
<p>“大雪菜”的写法：用栈模拟递归，对根结点的左子树，我们用中序遍历；对根结点的右子树，我们用反中序遍历。
则两个子树互为镜像，当且仅当同时遍历两棵子树时，对应结点的值相等。</p>
<p>时间复杂度：树中每个结点仅被遍历一遍，所以时间复杂度是 $O(n)$。</p>
<p>C++ 代码：</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        stack&lt;TreeNode*&gt; left, right;
        TreeNode *lc = root-&gt;left;
        TreeNode *rc = root-&gt;right;
        while(lc || rc || left.size())
        {
            while (lc &amp;&amp; rc)
            {
                left.push(lc), right.push(rc);
                lc = lc-&gt;left, rc = rc-&gt;right;
            }
            if (lc || rc) return false;
            lc = left.top(), rc = right.top();
            left.pop(), right.pop();
            if (lc-&gt;val != rc-&gt;val) return false;
            // 这里反过来操作
            lc = lc-&gt;right, rc = rc-&gt;left;
        }
        return true;
    }

};
</code></pre>
<p>作者：yxc
链接：https://www.acwing.com/solution/AcWing/content/747/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="29">第 29 题：顺时针打印矩阵</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/39/">顺时针打印矩阵</a>，<a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>样例：</p>
<p>输入：
<code>[
      [1, 2, 3, 4],
      [5, 6, 7, 8],
      [9,10,11,12]
]</code></p>
<p>输出：<code>[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</code></p>
</blockquote>
<p>分析：
+ 这道题，书本上的解法我个人觉得还不够直观、简洁，要考虑到一些边界情况。
+ 借用之前做题中，使用状态以及状态转移的策略，不难画出图形如下。</p>
<p>下面是对这张图的解释，我们只解释了一个状态执行的代码，其它状态可以同样分析得出。</p>
<ul>
<li>在初始状态下，应该向右边走，因此状态为“RIGHT”（或许，这里定义成“方向”会更贴切一些）。</li>
<li>遍历完第 1 行，其实以后，我们都不会再遍历到横坐标为 0 的点，因此 row_min 加 1。</li>
<li>遍历完成以后，其实点的坐标越界了，我们要把它挪到下一次状态的起点。</li>
<li>如果遍历到中心的时候，很可能遇到只更改了状态，不执行循环体的情况，这就避免了对一些边界情况的考虑。</li>
</ul>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.ArrayList;

// 29 顺时针打印矩阵
// 参考资料：https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a
public class Solution {

    private enum State {
        RIGHT, DOWN, LEFT, UP
    }

    public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) {
        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        int row_max = matrix.length;
        if (row_max == 0) {
            return res;
        }
        int col_max = matrix[0].length;
        row_max--;
        col_max--;
        int row_min = 0;
        int col_min = 0;
        // 上面的代码虽然看起来行数比较多，但是其实只是做了极端情况的考虑和一些变量的初始化工作

        // 下面的代码虽然看起来比较长，但是也只是做了当前状态的判断以及状态转移，代码框架是一模一样的
        // 仔细体会这个过程，其实就是：每次接收一个状态，根据这个状态做出相应的操作，然后变更状态
        State state = State.RIGHT;
        int i = 0;
        int j = 0;
        while (row_min &lt;= row_max &amp;&amp; col_min &lt;= col_max) {
            if (state == State.RIGHT) {
                while (j &lt;= col_max) {
                    res.add(matrix[i][j]);
                    j++;
                }
                j--;
                i++;
                state = State.DOWN;
                row_min++;
            } else if (state == State.DOWN) {
                while (i &lt;= row_max) {
                    res.add(matrix[i][j]);
                    i++;
                }
                i--;
                j--;
                state = State.LEFT;
                col_max--;
            } else if (state == State.LEFT) {
                while (j &gt;= col_min) {
                    res.add(matrix[i][j]);
                    j--;
                }
                j++;
                i--;
                state = State.UP;
                row_max--;
            } else {
                assert state == State.UP;
                while (i &gt;= row_min) {
                    res.add(matrix[i][j]);
                    i--;
                }
                i++;
                j++;
                state = State.RIGHT;
                col_min++;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        int[][] matrix1 = {{1, 2, 3, 4},
                {5, 6, 7, 8},
                {9, 10, 11, 12},
                {13, 14, 15, 16}};
        int[][] matrix = new int[5][6];
        int count = 1;
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix[0].length; j++) {
                System.out.print(count + &quot;\t&quot;);
                matrix[i][j] = count;
                count++;
            }
            System.out.println();
        }
        Solution solution = new Solution();
        ArrayList&lt;Integer&gt; printMatrix = solution.printMatrix(matrix);
        System.out.println(printMatrix);
    }
}
</code></pre>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        rows = len(matrix)
        cols = len(matrix[0])
        result = []
        if rows == 0 and cols == 0:
            return result
        left, right, top, buttom = 0, cols - 1, 0, rows - 1
        while left &lt;= right and top &lt;= buttom:
            for i in range(left, right + 1):
                result.append(matrix[top][i])
            for i in range(top + 1, buttom + 1):
                result.append(matrix[i][right])
            if top != buttom:
                for i in range(left, right)[::-1]:
                    result.append(matrix[buttom][i])
            if left != right:
                for i in range(top + 1, buttom)[::-1]:
                    result.append(matrix[i][left])
            left += 1
            top += 1
            right -= 1
            buttom -= 1
        return result
</code></pre>
<p>“大雪菜”的写法：我们顺时针定义四个方向：上右下左。从左上角开始遍历，先往右走，走到不能走为止，然后更改到下个方向，再走到不能走为止，依次类推，遍历 $n^2$ 个格子后停止。</p>
<p>时间复杂度：矩阵中每个格子遍历一次，所以总时间复杂度是 $O(n^2)$。</p>
<p>C++ 代码：</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; res;
        if (matrix.empty()) return res;
        int n = matrix.size(), m = matrix[0].size();
        vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false));
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y = 0, d = 1;
        for (int k = 0; k &lt; n * m; k ++ )
        {
            res.push_back(matrix[x][y]);
            st[x][y] = true;

            int a = x + dx[d], b = y + dy[d];
            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b])
            {
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};

</code></pre>
<p>作者：yxc
链接：https://www.acwing.com/solution/AcWing/content/748/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="30-min">第 30 题：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/90/">AcWing：包含min函数的栈</a>，<a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>设计一个支持 push，pop，top 等操作并且可以在 O(1) 时间内检索出最小元素的堆栈。</p>
<ul>
<li>push(x)–将元素x插入栈中</li>
<li>pop()–移除栈顶元素</li>
<li>top()–得到栈顶元素</li>
<li>getMin()–得到栈中最小元素</li>
</ul>
<p>样例：</p>
<p><code>MinStack minStack = new MinStack();
minStack.push(-1);
minStack.push(3);
minStack.push(-4);
minStack.getMin();   --&gt; Returns -4.
minStack.pop();
minStack.top();      --&gt; Returns 3.
minStack.getMin();   --&gt; Returns -1.</code></p>
</blockquote>
<p>思路：</p>
<ul>
<li>定义两个栈，一个存放入的值，另一个存最小值，两个栈应该是同步 push 和 pop，否则还要分类讨论，代码编写容易出错。</li>
<li>因为要用 $O(1)$ 实现当前栈中最小，很容易想到用空间换时间，因此可以设置一个和底层 <code>Stack</code> 同步的、称之为“最小栈”的栈成员。具体操作如下代码所示。</li>
</ul>
<p>Python 代码：</p>
<pre><code class="language-python">class MinStack(object):

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stack = []
        self.helper = []

    def push(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: void
        &quot;&quot;&quot;

        if len(self.stack) == 0:
            self.helper.append(x)
            self.stack.append(x)
        else:
            # 如果将要 push 的元素比辅助栈的栈顶元素还大，不能放这个元素，
            # 此时应该把辅助栈的栈顶元素再复制一份
            peek = self.helper[-1]
            if x &gt; peek:
                self.stack.append(x)
                self.helper.append(peek)
            else:
                self.stack.append(x)
                self.helper.append(x)


    def pop(self):
        &quot;&quot;&quot;
        :rtype: void
        &quot;&quot;&quot;

        if len(self.stack) == 0:
            return
        # 同步 pop 元素
        self.helper.pop()
        return self.stack.pop()

    def top(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        return self.stack[-1]

    def getMin(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        return self.helper[-1]
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.Stack;

public class Solution {

    private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();
    private Stack&lt;Integer&gt; dataStack = new Stack&lt;&gt;();

    public void push(int node) {
        if (minStack.isEmpty()) {
            minStack.push(node);
            dataStack.push(node);
            return;
        }
        int curMin = minStack.peek();
        if (node &lt; curMin) {
            minStack.push(node);
        } else {
            minStack.push(curMin);
        }
        dataStack.push(node);
    }

    public void pop() {
        minStack.pop();
        dataStack.pop();
    }

    public int top() {
        return dataStack.pop();
    }

    public int min() {
        return minStack.peek();
    }
}
</code></pre>
<p>思路2：我们除了维护基本的栈结构之外，还需要维护一个“辅助栈”。下面介绍如何维护单调栈：做到以下两点，辅助栈的栈顶元素，就是当前栈中的最小数。</p>
<p>1、当我们向栈中压入一个数时，如果该数小于（只要小于）“辅助栈”的栈顶元素，则将该数同时压入“辅助栈”中；否则，不压入。由于栈具有先进后出性质，所以在该数被弹出之前，“辅助栈”中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。</p>
<p>2、当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，同时将单调栈的栈顶元素弹出。</p>
<p>时间复杂度：四种操作都只有常数次入栈出栈操作，所以时间复杂度都是 $O(1)$。</p>
<p>Python 代码：</p>
<pre><code class="language-python"># 定义两个栈，一个存放入的值，另一个存最小值，两个栈应该是同步 push 和 pop，否则还要分类讨论，代码编写容易出错。


class MinStack(object):

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stack = []
        self.helper = []

    def push(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: void
        &quot;&quot;&quot;
        # 无论如何都 push
        self.stack.append(x)
        # 如果放入的元素小于辅助栈顶元素，辅助栈顶才 push，否则什么都不做
        if not self.helper or self.helper[-1] &gt; x:
            self.helper.append(x)

    def pop(self):
        &quot;&quot;&quot;
        :rtype: void
        &quot;&quot;&quot;

        if len(self.stack) == 0:
            return
        # 如果弹出的元素等于辅助栈栈顶元素，才将辅助栈顶元素弹出
        if self.helper[-1] == self.stack[-1]:
            self.helper.pop()
        return self.stack.pop()

    def top(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        return self.stack[-1]

    def getMin(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        return self.helper[-1]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.Stack;

public class Solution {

    private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();
    private Stack&lt;Integer&gt; dataStack = new Stack&lt;&gt;();

    public void push(int node) {
        if (minStack.isEmpty()) {
            minStack.push(node);
            dataStack.push(node);
            return;
        }
        int curMin = minStack.peek();
        if (node &lt; curMin) {
            minStack.push(node);
        } else {
            minStack.push(curMin);
        }
        dataStack.push(node);
    }

    public void pop() {
        minStack.pop();
        dataStack.pop();
    }

    public int top() {
        return dataStack.pop();
    }

    public int min() {
        return minStack.peek();
    }
}
</code></pre>
<p>LeetCode 第 155 题：最小栈</p>
<p>设置一个辅助栈，保存当前最小的元素。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class MinStack(object):

    # 【特别注意】数据栈和辅助栈要同步，特殊测试用例为：
    # 依次 push 0 1 0，马上弹栈，查询最小

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        # 数据栈
        self.data_stack = []
        # 辅助栈
        self.help_stack = []

    def push(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: void
        &quot;&quot;&quot;
        self.data_stack.append(x)
        if len(self.help_stack) == 0 or x &lt; self.help_stack[-1]:
            self.help_stack.append(x)
        else:
            self.help_stack.append(self.help_stack[-1])

    def pop(self):
        &quot;&quot;&quot;
        :rtype: void
        &quot;&quot;&quot;
        if len(self.data_stack) &gt; 0:
            ret = self.data_stack.pop()
            self.help_stack.pop()
            return ret

    def top(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.data_stack) &gt; 0:
            return self.data_stack[-1]

    def getMin(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if len(self.data_stack) &gt; 0:
            return self.help_stack[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
if __name__ == '__main__':
    min_stack = MinStack()
    min_stack.push(0)
    min_stack.push(1)
    min_stack.push(0)
    print(min_stack.getMin())
    min_stack.pop()
    print(min_stack)

    print(min_stack.getMin())
</code></pre>
<p>（本节完）</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
