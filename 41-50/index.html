<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>41 50 - 《剑指 Offer》（第 2 版）</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "41 50";
    var mkdocs_page_input_path = "41-50.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> 《剑指 Offer》（第 2 版）</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">首页</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 1 - 20 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../03/">剑指 Offer 03. 数组中重复的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../04/">剑指 Offer 04. 二维数组中的查找</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../05/">剑指 Offer 05. 替换空格</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../06/">剑指 Offer 06. 从尾到头打印链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../07/">剑指 Offer 07. 重建二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../08/">剑指 Offer 08. 二叉树的下一个结点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../09/">剑指 Offer 09. 用两个栈实现队列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../10-1/">剑指 Offer 10- I. 斐波那契数列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../10-2/">剑指 Offer 10- II. 青蛙跳台阶问题</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../11/">剑指 Offer 11. 旋转数组的最小数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../12/">剑指 Offer 12. 矩阵中的路径</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../13/">剑指 Offer 13. 机器人的运动范围</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../14-1/">剑指 Offer 14- I. 剪绳子</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../14-2/">剑指 Offer 14- II. 剪绳子 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../15/">剑指 Offer 15. 二进制中1的个数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../16/">剑指 Offer 16. 数值的整数次方</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../17/">剑指 Offer 17. 打印从1到最大的n位数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../18/">剑指 Offer 18. 删除链表的节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../19/">剑指 Offer 19. 正则表达式匹配</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../20/">剑指 Offer 20. 表示数值的字符串</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 21 - 40 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../21/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../22/">剑指 Offer 22. 链表中倒数第k个节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../24/">剑指 Offer 24. 反转链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../25/">剑指 Offer 25. 合并两个排序的链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../26/">剑指 Offer 26. 树的子结构</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../27/">剑指 Offer 27. 二叉树的镜像</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../28/">剑指 Offer 28. 对称的二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../29/">剑指 Offer 29. 顺时针打印矩阵</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../30/">剑指 Offer 30. 包含min函数的栈</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../31/">剑指 Offer 31. 栈的压入、弹出序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-1/">剑指 Offer 32 - I. 从上到下打印二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-2/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-3/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../33/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../34/">剑指 Offer 34. 二叉树中和为某一值的路径</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../35/">剑指 Offer 35. 复杂链表的复制</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../36/">剑指 Offer 36. 二叉搜索树与双向链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../37/">剑指 Offer 37. 序列化二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../38/">剑指 Offer 38. 字符串的排列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../39/">剑指 Offer 39. 数组中出现次数超过一半的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../40/">剑指 Offer 40. 最小的k个数</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 41 - 60 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../41/">剑指 Offer 41. 数据流中的中位数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../42/">剑指 Offer 42. 连续子数组的最大和</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../43/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../44/">剑指 Offer 44. 数字序列中某一位的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../45/">剑指 Offer 45. 把数组排成最小的数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../46/">剑指 Offer 46. 把数字翻译成字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../47/">剑指 Offer 47. 礼物的最大价值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../48/">剑指 Offer 48. 最长不含重复字符的子字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../49/">剑指 Offer 49. 丑数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../50/">剑指 Offer 50. 第一个只出现一次的字符</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../51/">剑指 Offer 51. 数组中的逆序对</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../52/">剑指 Offer 52. 两个链表的第一个公共节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../53/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../53-2/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../54/">剑指 Offer 54. 二叉搜索树的第k大节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../55/">剑指 Offer 55 - I. 二叉树的深度</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../55-2/">剑指 Offer 55 - II. 平衡二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../56/">剑指 Offer 56 - I. 数组中数字出现的次数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../56-2/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../57/">剑指 Offer 57. 和为s的两个数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../57-2/">剑指 Offer 57 - II. 和为s的连续正数序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../58/">剑指 Offer 58 - I. 翻转单词顺序</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../58-2/">剑指 Offer 58 - II. 左旋转字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../59/">剑指 Offer 59 - I. 滑动窗口的最大值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../59-2/">剑指 Offer 59 - II. 队列的最大值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../60/">剑指 Offer 60. n个骰子的点数</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 61 - 68 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../61/">剑指 Offer 61. 扑克牌中的顺子</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../62/">剑指 Offer 62. 圆圈中最后剩下的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../63/">剑指 Offer 63. 股票的最大利润</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../64/">剑指 Offer 64. 求1+2+…+n</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../65/">剑指 Offer 65. 不用加减乘除做加法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../66/">剑指 Offer 66. 构建乘积数组</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../67/">剑指 Offer 67. 把字符串转换成整数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../68/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../68-2/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">《剑指 Offer》（第 2 版）</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>41 50</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <p>41-50</p>
<h1 id="offer-2-python-41-50">《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 41-50 题</h1>
<h3 id="41">第 41 题：数据流中的中位数</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/88/">AcWing：数据流中的中位数</a>。</p>
<p>如何得到一个数据流中的中位数？</p>
<p>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。</p>
<p>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>样例</p>
<pre><code>输入：1, 2, 3, 4

输出：1,1.5,2,2.5

解释：每当数据流读入一个数据，就进行一次判断并输出当前的中位数。
</code></pre>
<p>参考资料：<a href="https://www.zybuluo.com/liweiwei1419/note/1396029">LeetCode 第 295 题：数据流的中位数</a>。</p>
<p><img alt="《剑指 Offer （第 2 版）》第 41 题：数据流中的中位数-1" src="http://upload-images.jianshu.io/upload_images/414598-2092808c73da36b8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img alt="《剑指 Offer （第 2 版）》第 41 题：数据流中的中位数-2" src="http://upload-images.jianshu.io/upload_images/414598-15c2347cdb5346ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>问题：1、上面的思路是很简单的，想想用 Python 如何实现。</p>
<p>2、LeetCode 上面第 4 题：排序数组的中位数如何求？</p>
<p>另一种使用堆的解法：这道题是堆解决的问题。</p>
<p>用两个堆：max heap 和 min heap，再一个median值， 维持两个堆的大小相等(max堆可以比min堆多一个).  对于新来的元素，比较新元素和median的大小，如果大于median就放入最小堆里面，如果小于median就放入最大堆里面，如果max heap,和min heap不平衡了，就调整一下。 然后调整过后median 里面的值就是我们要求的中位数。</p>
<p><img alt="《剑指 Offer （第 2 版）》第 41 题：数据流中的中位数-3" src="http://upload-images.jianshu.io/upload_images/414598-9bb0f1aed7b1b06b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>C++ 代码：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 41 题：数据流中的中位数-4" src="http://upload-images.jianshu.io/upload_images/414598-83b064f0edd86536.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h3 id="42">第 42 题：连续子数组的最大和</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/50/">连续子数组的最大和</a>，<a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一个 <strong>非空</strong> 整型数组，数组里的数可能为正，也可能为负。</p>
<p>数组中一个或连续的多个整数组成一个子数组。</p>
<p>求所有子数组的和的最大值。</p>
<p>要求时间复杂度为 $O(n)$。</p>
<p>样例：</p>
<p>输入：<code>[1, -2, 3, 10, -4, 7, 2, -5]</code></p>
<p>输出：18</p>
</blockquote>
<p>同 LeetCode 第 53 题，题解传送门：<a href="https://www.zybuluo.com/liweiwei1419/note/1394321">LeetCode 第 53 题：连续子数组的最大和</a>。</p>
<p>“大雪菜”的做法：状态：以前一个数结尾的“连续子数组的最大和”为状态。</p>
<p>C++ 代码：</p>
<p><img alt="image.png" src="https://upload-images.jianshu.io/upload_images/414598-65b3941dfc3e24b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>分析：</p>
<ul>
<li>
<p>根据“最长公共子序列”问题的思路，我们在考虑数组的时候，定义以当前数组元素为结尾的连续子数组，往往会使用情况变得简单一些。</p>
</li>
<li>
<p>设置状态：<code>dp[i]</code> 以 <code>i</code> 结尾的子数组的最大和。</p>
</li>
<li>考虑状态转移方程：</li>
</ul>
<p>如果 <code>nums[i] &lt; 0，dp[i] = max(dp[i-1] + nums[i],nums[i])</code>; 
如果 <code>nums[i] &gt;= 0，dp[i] = dp[i-1] + nums[i]</code>;</p>
<p>综上所述，不论当前考虑的数组元素是大于等于 0 还是小于 0，只要满足 <code>dp[i] = max(dp[i-1] + nums[i], nums[i])</code> 就可以了，这就是状态转移方程。</p>
<p>Java 代码：</p>
<pre><code class="language-java">public class Solution {

    public int FindGreatestSumOfSubArray(int[] array) {
        int n = array.length;
        if (n == 0) {
            return 0;
        }
        int[] dp = new int[n];
        dp[0] = array[0];
        int res = array[0];
        for (int i = 1; i &lt; n; i++) {
            dp[i] = Integer.max(dp[i - 1] + array[i], array[i]);
            res = Integer.max(res, dp[i]);
        }
        return res;
    }

    public static void main(String[] args) {
        int[] nums = new int[]{6, -3, -2, 7, -15, 1, 2, 2};
        Solution solution = new Solution();
        int findGreatestSumOfSubArray = solution.FindGreatestSumOfSubArray(nums);
        System.out.println(findGreatestSumOfSubArray);
    }
}
</code></pre>
<h3 id="43-1-1-n-1">第 43 题：整数中 1 出现的次数（从 1 到 n 整数中 1 出现的次数）</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/51/">AcWing：从 1 到 n 整数中 1 出现的次数</a>。</p>
<blockquote>
<p>输入一个整数 $n$，求从 $1$ 到 $n$ 这 $n$ 个整数的十进制表示中 $1$ 出现的次数。</p>
<p>例如输入 $12$，从 $1$ 到 $12$ 这些整数中包含 $1$ 的数字有 $1$，$10$，$11$ 和 $12$，“$1$” 一共出现了 $5$ 次。</p>
<p>样例：</p>
<p>输入： 12
输出： 5</p>
</blockquote>
<p>同 LeetCode 第 233 题：数字 $1$ 的个数。</p>
<p>大雪菜的解法：</p>
<p>C++ 代码：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 43 题：整数中 1 出现的次数（从 1 到 n 整数中 1 出现的次数）-1" src="https://upload-images.jianshu.io/upload_images/414598-101464ca2342b718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>思路：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 43 题：整数中 1 出现的次数（从 1 到 n 整数中 1 出现的次数）-2" src="http://upload-images.jianshu.io/upload_images/414598-938a575bcbc5be96.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<pre><code class="language-python"># 56. 从1到n整数中1出现的次数
#
# 输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。
#
# 例如输入12，从1到12这些整数中包含“1”的数字有1，10，11和12，其中“1”一共出现了5次。
#
# 样例
# 输入： 12
# 输出： 5
class Solution(object):
    def numberOf1Between1AndN_Solution(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        if n &lt;= 0:
            return 0

        number = []
        while n:
            number.append(n % 10)
            n //= 10

        res = 0
        for i in range(len(number) - 1, -1, -1):
            left = 0
            right = 0
            # 想清楚这里 t 为什么从 1 开始
            t = 1
            for j in range(len(number) - 1, i, -1):
                left = left * 10 + number[j]

            for j in range(i - 1, -1, -1):
                right = right * 10 + number[j]
                t *= 10
            # print(left, right)
            # 至少有左边的数这么多
            res += left * t
            # print(number[i], left, right, t, left * t)
            if number[i] == 1:
                res += right + 1
            elif number[i] &gt; 1:
                res += t
        return res


if __name__ == '__main__':
    solution = Solution()
    n = 45032
    result = solution.numberOf1Between1AndN_Solution(n)
    print('result', result)
</code></pre>
<p>解法1：从 $1$ 到 $n$ 遍历，每个数通过对 $10$ 求余数判断整数的个位数字是不是 $1$，大于 $10$ 的除以 $10$ 之后再判断。我们对每个数字都要做除法和求余运算以求出该数字中 $1$ 出现的次数。如果输入数字 $n$，$n$ 有 $O(\log n)$ 位，我们需要判断每一位是不是 $1$，那么时间复杂度为 $O(n* \log n)$。这样做，计算量大，效率不高。</p>
<p>本文采用《数学之美》上面提出的方法，设定整数点（如 $1$、$10$、$100$等等）作为位置点$i$（对应 $n$的个位、十位、百位等等），分别对每个数位上有多少包含 $1$ 的点进行分析。</p>
<p>根据设定的整数位置，对 $n$ 进行分割，分为两部分，高位 $n/i$，低位 $n \% i$；</p>
<p>1、当 $i$ 表示百位，且百位对应的数 $\ge2$，</p>
<p>例如 $n=31456$，此时考虑 $i=100$，则 $a=314$，$b=56$。</p>
<p>此时百位为 $1$ 的次数有 $a/10+1=32$ 批次，具体如下：</p>
<p>说明：第 1 批次：$00100-00199$，一共 $100$ 个数；</p>
<p>第 2 批次：$01100-01199$，一共 $100$ 个数；</p>
<p>……</p>
<p>第 32 批次：$31100-31199$，一共 $100$ 个数；</p>
<p>最高两位 $0-31$，每一批次都包含 $100$ 个连续的点，即共有 $(a/10+1)\times100$ 个点的百位为 $1$；</p>
<p>2、当 $i$ 表示百位，且百位对应的数为 $1$，</p>
<p>例如 $n=31156$，$i=100$，则 $a=311$，$b=56$，此时百位对应的就是 $1$。</p>
<p>第 1 批次：$00100-00199$，一共 $100$ 个数；</p>
<p>第 2 批次：$01100-01199$，一共 $100$ 个数；</p>
<p>……</p>
<p>第 31 批次：$30100-30199$，一共 $100$ 个数；</p>
<p>第 32 批次：$31100-311569$，一共 $57$ 个数；</p>
<p>则共有 $a/10$ 次是包含 $100$ 个连续点，最高两位 $0-30$。</p>
<p>当最高两位为 $31$（即 $a=311$），本次只对应局部点 $00-56$，共 $b+1$次，所有点加起来共有 $（a/10\times100）+(b+1)$，这些点百位对应为 $1$;</p>
<p>3、当 $i$ 表示百位，且百位对应的数为 $0$，如 $n=31056$，$i=100$，则 $a=310$，$b=56$。</p>
<p>第 1 批次：$00100-00199$，一共 $100$ 个数；</p>
<p>第 2 批次：$01100-01199$，一共 $100$ 个数；</p>
<p>……</p>
<p>第 31 批次：$30100-30199$，一共 $100$ 个数；</p>
<p>第 32 批次：$31000-31056$，一共 $0$ 个数；</p>
<p>此时百位为 $1$ 的次数有 $a/10=31$，最高两位 $0-30$；</p>
<p>综合以上 $3$ 种情况，当百位对应 $0$ 或 $\ge2$ 时，有 $(a+8)/10$ 次包含所有 $100$ 个点，还有当百位为 $1$ （$a\%10==1$），需要增加局部点 $b+1$。</p>
<p>之所以补 $8$，是因为当百位为 $0$，则 $a/10==(a+8)/10$，当百位 $\ge2$，补 $8$ 会产生进位，效果等同于 $(a/10+1)$。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        # write code here
        count = 0
        i = 1
        while i &lt;= n:
            a = n / i
            b = n % i
            count += (a+8) / 10 * i + (a % 10 == 1)*(b + 1)
            i *= 10
        return count
</code></pre>
<p>参考资料：https://blog.csdn.net/qq_38211852/article/details/80863364</p>
<p>https://cuijiahua.com/blog/2017/12/basis_31.html</p>
<h3 id="44">第 44 题：数字序列中某一位的数字</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/52/">数字序列中某一位的数字</a>。</p>
<blockquote>
<p>数字以 <code>0123456789101112131415…</code> 的格式序列化到一个字符序列中。</p>
<p>在这个序列中，第 5 位（从 0 开始计数）是 5 ，第 13 位是 1 ，第 19 位是 4 ，等等。</p>
<p>请写一个函数求任意位对应的数字。</p>
<p>样例：</p>
<p>输入：13</p>
<p>输出：1</p>
</blockquote>
<p>Python 代码：参考了 LeetCode 第 400 题讨论区代码</p>
<pre><code class="language-python">class Solution(object):
    def digitAtIndex(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;

        # 如果 n 小于 10 ，直接返回就可以了
        if n &lt; 10:
            return n

        # 计算前缀部分

        base = 9
        digits = 1
        # 2 位数，从 10 到 99 一共 ( 99 - 10 + 1) * 2 = 90 * 2 = 180 位
        # 3 位数，从 100 到 999 一共 ( 999 - 100 + 1) * 2 = 900 * 3 = 2700 位
        # 4 位数，从 1000 到 9999 一共 ( 9999 - 1000 + 1) * 2 = 9000 * 4 = 3600 位

        while n - base * digits &gt; 0:
            n -= base * digits
            base *= 10
            digits += 1


        index = n % digits
        if index == 0:
            # 计算出 num 是多少
            # 例如：192，有 1 个位移的偏差
            num = 10 ** (digits - 1) + n // digits - 1
            # 返回个位就可以了
            return num % 10
        else:
            # 不能整除，那个偏移就不用算了
            # 例如 194 = 189 + 5
            # 100 + 2 = 102
            num = 10 ** (digits - 1) + n // digits
            # 从左边向右边数，第 2 位
            for i in range(index, digits):
                num //= 10
            return num % 10
</code></pre>
<p>参考资料：</p>
<p>1、https://www.acwing.com/activity/content/code/content/20758/</p>
<p>2、https://blog.csdn.net/Koala_Tree/article/details/79536284</p>
<p>[站外图片上传中...(image-a760ae-1558582697894)]</p>
<p>思路：跳过不同位数的数字，在相应位数中寻找。</p>
<p>以序列中第 $1001$ 位为例：</p>
<p>1、序列前 $10$ 位为 $0$ 到 $9$，跳过，再从后面找 $991$ 位；</p>
<p>2、后面 $180$ 位为 $10$ 到 $99$，因为一共  $99-10+1=90$ 个数，每个数 $2$ 位，所以 $180$ 位； 跳过，再从后面找 $811$ 位（$1001-10-180=811$）；</p>
<p>后面 $2700$ 位为 $100$ 到 $999$，因为 $811&lt;2700$，所以 $811$ 位是某个三位数中的一位；
由于811=270*3+1，这就是说811位是从100开始的第270个数字即370的中间一位，即7。(注意，这里都是从第0位开始计数的)</p>
<hr />
<p>作者：Koala_Tree 
来源：CSDN 
原文：https://blog.csdn.net/Koala_Tree/article/details/79536284 
版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<p>Java 代码：</p>
<pre><code class="language-java">class Solution {  // 9*1  9*10*2  9*10*10*3
    public int digitAtIndex(int n) {
        int len = 1;
        long count = 9;
        int start = 1;

        while (n &gt; len * count) {  //13  n=n-9=4 len=2 count=90 start=10 
            n -= len * count;      //start=10+3/2=11   答案是11的第二个1
            len += 1;
            count *= 10;
            start *= 10;
        }
        // start 记录当前循环区间的第一个数字，当 n 落到某一个确定的区间里了,
        // 那么 (n-1)/len 就是目标数字在该区间里的坐标，加上 start 就是得到了目标数字
        start += (n - 1) / len;
        String s = Integer.toString(start);
        return Character.getNumericValue(s.charAt((n - 1) % len));

    }
}
</code></pre>
<p>参考资料：这篇简书上的文章有详细步骤。https://www.jianshu.com/p/0bbf1fcbe070。</p>
<h3 id="leetcode-400-400-n">同 LeetCode 第 400 题：<a href="https://leetcode-cn.com/problems/nth-digit/">400. 第 N 个数字</a></h3>
<p>说明：只不过 LeetCode 第 400 题从 1 开始，传送门：<a href="https://leetcode-cn.com/problems/nth-digit/">400. 第 N 个数字</a>。</p>
<blockquote>
<p>在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 <em>n</em> 个数字。</p>
<p><strong>注意:</strong>
<em>n</em> 是正数且在32为整形范围内 ( <em>n</em> &lt; 231)。</p>
<p><strong>示例 1:</strong></p>
<p>```
输入:
3</p>
<p>输出:
3
```</p>
<p><strong>示例 2:</strong></p>
<p>```
输入:
11</p>
<p>输出:
0</p>
<p>说明:
第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。
```</p>
</blockquote>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def findNthDigit(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        # 特判：如果 n 小于 10 ，直接返回就可以了
        if n &lt; 10:
            return n

        # 表示几位数
        # 2 位数，从 10 到 99 一共 ( 99 - 10 + 1) * 2 = 90 * 2 = 180 位
        # 3 位数，从 100 到 999 一共 ( 999 - 100 + 1) * 2 = 900 * 3 = 2700 位
        # 4 位数，从 1000 到 9999 一共 ( 9999 - 1000 + 1) * 2 = 9000 * 4 = 3600 位

        # 步骤1：calculate how many digits the number has

        # 计算前缀部分
        length = 0
        base = 9
        digits = 1

        # n = 1001 时，9 过，180 过，剩下 812

        # 不越界才加，要清楚这一点
        while length + base * digits &lt; n:
            length += base * digits
            base *= 10
            digits += 1

        n -= length

        # step 2. calculate what the number is
        # 到这里，num 是 &quot;digits 位数&quot; 中的某一个数字
        # 以 digits = 3 为例，n 是 100 - 999 中的一位，num 表示是哪个数字

        index = n % digits

        if index == 0:
            # 如果整除，就是那个数字的最后一位
            num = 10 ** (digits - 1) + n // digits - 1
            return num % 10
        else:
            num = 10 ** (digits - 1) + n // digits
            for i in range(index, digits):
                num //= 10
            return num % 10


if __name__ == '__main__':
    solution = Solution()
    n = 190
    result1 = solution.findNthDigit(n)
    print(result1)

</code></pre>
<h3 id="45">第 45 题：把数组排成最小的数</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/54/">把数组排成最小的数</a>，<a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>例如输入数组 <code>[3, 32, 321]</code>，则打印出这 3 个数字能排成的最小数字 <code>321323</code>。</p>
<p>样例：</p>
<p>输入：<code>[3, 32, 321]</code></p>
<p>输出：<code>321323</code></p>
<p><strong>注意</strong>：输出数字的格式为字符串。</p>
</blockquote>
<p>同 LeetCode  第 179 题，<a href="https://leetcode-cn.com/problems/largest-number/">最大数</a>。</p>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {

    public String PrintMinNumber(int[] numbers) {
        int len = numbers.length;
        if (len == 0) {
            return &quot;&quot;;
        }
        String[] numsStr = new String[len];
        for (int i = 0; i &lt; len; i++) {
            numsStr[i] = numbers[i] + &quot;&quot;;
        }
        Arrays.sort(numsStr, (a, b) -&gt; (a + b).compareTo(b + a));
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; len; i++) {
            builder.append(numsStr[i]);
        }
        return builder.toString();
    }

    public static void main(String[] args) {
        int[] nums = new int[]{3, 32, 321};
        Solution solution = new Solution();
        String printMinNumber = solution.PrintMinNumber(nums);
        System.out.println(printMinNumber);
    }
}
</code></pre>
<p>说明：其实就定义自定义排序规则。Python3 想用 cmp 而不是 key 的话，需要 <code>from functools import cmp_to_key</code> ，然后 sort 或者 sorted 的时候 <code>key = cmp_to_key(your_comparator)</code> 。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution(object):
    def printMinNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: str
        &quot;&quot;&quot;

        if len(nums) == 0:
            return ''
        # 自定义排序规则
        from functools import cmp_to_key
        key_func = cmp_to_key(lambda a, b: int(a + b) - int(b + a))
        result = sorted(map(str, nums), key=key_func)
        return ''.join(result)


if __name__ == '__main__':
    list1 = [7, -8, 5, 4, 0, -2, -5]
    # 要求：1、正数在前负数在后
    # 2、正数从小到大
    # 3、负数从大到小

    result = sorted(list1, key=lambda x: (x &lt; 0, abs(x)))
    print(result)

    s = 'asdf234GDSdsf23'  # 排序:小写-大写-奇数-偶数

    print(
        &quot;&quot;.join(
            sorted(
                s,
                key=lambda x: (
                    x.isdigit(),
                    x.isdigit() and int(x) %
                    2 == 0,
                    x.isupper(),
                    x))))
</code></pre>
<p>另一种写法：</p>
<p>Python 代码：</p>
<pre><code class="language-python">class NumCompare(str):
    # 注意：这里继承 str 类
    def __lt__(self, other):
        return self + other &lt; other + self


class Solution(object):
    def printMinNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: str
        &quot;&quot;&quot;

        if len(nums) == 0:
            return ''
        # 自定义排序规则
        result = sorted(map(str, nums), key=NumCompare)
        return ''.join(result)
</code></pre>
<h3 id="46">第 46 题：把数字翻译成字符串</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/55/">把数字翻译成字符串</a>。</p>
<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：</p>
<p>0 翻译成 “a”，1 翻译成 “b”，……，11 翻译成“l”，……，25 翻译成 “z”。</p>
<p>一个数字可能有多个翻译。例如 12258 有 5 种不同的翻译，它们分别是 “bccfi”、“bwfi”、“bczi”、“mcfi” 和 “mzi”。</p>
<p>请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
<p>样例：</p>
<p>输入："12258"</p>
<p>输出：5</p>
</blockquote>
<p>思路：同 LeetCode 第 91 题 Decode Ways，使用动态规划。</p>
<p>状态定义：<code>dp[i]</code> 表示 <code>s[0, i]</code> （包括 <code>i</code> ），一共有多少种翻译的方法。</p>
<p>分类讨论：</p>
<p>1、当前字符可以单独翻译；</p>
<p>2、当前字符可以和前面一个字符一起翻译。</p>
<p><code>dp[i]</code> 就是以上二者之和。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def getTranslationCount(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        s = str(s)
        l = len(s)
        if l == 0:
            return 0
        dp = [None for _ in range(l)]

        # dp[i] 表示 s[0, i] ，包括 i ，一共有多少种翻译的方法

        dp[0] = 1
        for i in range(1, l):
            # 当前值至少是 dp[i - 1]，因为 s[i] 一定可以单独翻译
            cur = dp[i - 1]

            # 看一看 s[i-1,i] 是不是可以翻译
            if 9 &lt; int(s[i - 1:i + 1]) &lt; 26:
                if i - 2 &lt; 0:
                    # 12
                    cur += 1
                else:
                    # 要考虑到数组下标越界问题
                    cur += dp[i - 2]
            dp[i] = cur
        return dp[l - 1]
</code></pre>
<h3 id="leetcode-91">LeetCode 第 91 题：解码方法</h3>
<p>传送门：<a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a>。</p>
<blockquote>
<p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p>
<p><code>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26</code></p>
<p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p>
<p><strong>示例 1:</strong></p>
<p><code>输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。</code></p>
<p><strong>示例 2:</strong></p>
<p><code>输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。</code></p>
</blockquote>
<p>Python 代码：</p>
<pre><code class="language-python"># 91、解码方法
# 一条包含字母 A-Z 的消息通过以下方式进行了编码：
#
# 'A' -&gt; 1
# 'B' -&gt; 2
# ...
# 'Z' -&gt; 26
# 给定一个只包含数字的非空字符串，请计算解码方法的总数。


class Solution:

    def numDecodings(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;

        l = len(s)
        if l == 0:
            return 0

        if l == 1:
            return 1 if s[0] != '0' else 0
        dp = [0 for _ in range(l)]
        dp[0] = 1 if s[0] != '0' else 0
        for i in range(1, l):
            if s[i] != '0':
                # 如果不是 '0' ，那么 s[i] 就可以编码，所以 cur 就至少是  dp[i - 1]
                dp[i] += dp[i - 1]
            if 9 &lt; int(s[i - 1:i + 1]) &lt; 27:
                # 可以和前面的数字组成一个编码
                if i - 2 &lt; 0:
                    # 12
                    dp[i] += 1
                else:
                    dp[i] += dp[i - 2]
        return dp[l - 1]


if __name__ == '__main__':
    test_str = '12'
    s = Solution()
    res = s.numDecodings(test_str)
    print(res)
</code></pre>
<h3 id="47">第 47 题：礼物的最大价值</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/56/">礼物的最大价值</a>，<a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>在一个 m×n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。</p>
<p>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。</p>
<p>给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>m,n&gt;0</code></li>
</ul>
<p>样例：</p>
<p>输入：
<code>[
     [2,3,1],
     [1,7,1],
     [4,6,1]
]</code></p>
<p>输出：19</p>
<p>解释：沿着路径 <code>2→3→7→6→1</code> 可以得到拿到最大价值礼物。</p>
</blockquote>
<p>思路：动态规划。礼物要么来自左边一格，要么来自上面一格，两者取最大。要特殊判断的就是边界情况。另外可以使用一维数组完成动态规划。如果可以修改 grid，直接在 grid 上修改就可以了，不用辅助空间。</p>
<ul>
<li>动态规划。</li>
<li>可以尽量减少空间复杂度。</li>
</ul>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution(object):
    def getMaxValue(self, grid):
        &quot;&quot;&quot;
        :type grid: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;

        m = len(grid)
        if m == 0:
            return 0
        n = len(grid[0])

        dp = [None for _ in range(n)]

        dp[0] = grid[0][0]
        for i in range(1, n):
            dp[i] = dp[i - 1] + grid[0][i]

        for i in range(1, m):
            for j in range(n):
                if j == 0:
                    dp[j] += grid[i][0]
                else:
                    dp[j] = grid[i][j] + max(dp[j - 1], dp[j])

        return dp[n - 1]
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">public class Solution {

    public int getMaxValue(int[][] matrix) {
        int row = matrix.length;
        if (row == 0) {
            return 0;
        }
        int col = matrix[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = matrix[0][0];

        for (int j = 1; j &lt; col; j++) {
            dp[0][j] = dp[0][j - 1] + matrix[0][j];
        }
        for (int i = 1; i &lt; row; i++) {
            dp[i][0] = dp[i - 1][0] + matrix[i][0];
            for (int j = 1; j &lt; col; j++) {
                dp[i][j] = Integer.max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j];
            }
        }
        return dp[row - 1][col - 1];
    }

    public static void main(String[] args) {
        int[][] matrix = new int[][]{
                {1, 10, 3, 8},
                {12, 2, 9, 6},
                {5, 7, 4, 11},
                {3, 7, 16, 5}
        };
        Solution solution = new Solution();
        int maxValue = solution.getMaxValue(matrix);
        System.out.println(maxValue);
    }
}
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">public class Solution2 {

    public int getMaxValue(int[][] matrix) {
        int row = matrix.length;
        if (row == 0) {
            return 0;
        }
        int col = matrix[0].length;
        int[] dp = new int[col];
        dp[0] = matrix[0][0];

        for (int j = 1; j &lt; col; j++) {
            dp[j] = dp[j - 1] + matrix[0][j];
        }
        for (int i = 1; i &lt; row; i++) {
            dp[0] = dp[0] + matrix[i][0];
            for (int j = 1; j &lt; col; j++) {
                dp[j] = Integer.max(dp[j], dp[j - 1]) + matrix[i][j];
            }
        }
        return dp[col - 1];
    }

    public static void main(String[] args) {
        int[][] matrix = new int[][]{
                {1, 10, 3, 8},
                {12, 2, 9, 6},
                {5, 7, 4, 11},
                {3, 7, 16, 5}
        };
        Solution2 solution2 = new Solution2();
        int maxValue = solution2.getMaxValue(matrix);
        System.out.println(maxValue);
    }
}
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">public class Solution3 {

    public int getMaxValue(int[][] matrix) {
        int row = matrix.length;
        if (row == 0) {
            return 0;
        }
        int col = matrix[0].length;
        int[] dp = new int[col];
        for (int i = 0; i &lt; row; i++) {
            for (int j = 0; j &lt; col; j++) {
                dp[j] = Integer.max(dp[j], j - 1 &lt; 0 ? 0 : dp[j - 1]) + matrix[i][j];
            }
        }
        return dp[col - 1];
    }

    public static void main(String[] args) {
        int[][] matrix = new int[][]{
                {1, 10, 3, 8},
                {12, 2, 9, 6},
                {5, 7, 4, 11},
                {3, 7, 16, 5}
        };
        Solution3 solution3 = new Solution3();
        int maxValue = solution3.getMaxValue(matrix);
        System.out.println(maxValue);
    }
}
</code></pre>
<h3 id="48">第 48 题：最长不重复字符串的子字符串</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/57/">最长不含重复字符的子字符串</a>。</p>
<blockquote>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>假设字符串中只包含从’a’到’z’的字符。</p>
<p>样例：</p>
<p>输入："abcabc"</p>
<p>输出：3</p>
</blockquote>
<p>思路1：滑动窗口：</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        # 特判
        size = len(s)
        if size &lt; 2:
            return size
        l = 0
        r = -1
        counter = [0 for _ in range(256)]
        res = 1
        while l &lt; size:
            # 首先&quot;右指针&quot;不断向右边尝试，走到出现重复的最右边
            while r + 1 &lt; size and counter[ord(s[r + 1])] == 0:
                # 表示没有重复元素，r 可以加 1
                counter[ord(s[r + 1])] += 1
                r += 1
            # 此时，记录不重复子串是&quot;左指针&quot;固定时候最长
            res = max(res, r - l + 1)
            # 考虑移动&quot;左指针&quot;
            # 此时 s[r+1] 就是已经扫过的区间里重复的元素，要把它剔除出去
            while r + 1 &lt; size and s[l] != s[r + 1]:
                # 有重复元素，左边就要减 1
                counter[ord(s[l])] -= 1
                l += 1
            # 出了上一个循环以后，还要再把左指针向右移动一格，否则右指针不能向右移动
            counter[ord(s[l])] -= 1
            l += 1
        return res
</code></pre>
<p>思路2：动态规划</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        # 特判
        l = len(s)
        if l &lt; 2:
            return l
        # dp[i] 表示以 s[i] 结尾的最长不重复子串的长度
        # 因为自己肯定是不重复子串，所以初始值设置为 1
        dp = [1 for _ in range(l)]
        map = dict()
        map[s[0]] = 0
        for i in range(1, l):
            if s[i] in map:
                if i - map[s[i]] &gt; dp[i - 1]:
                    dp[i] = dp[i - 1] + 1
                else:
                    dp[i] = i - map[s[i]]
            else:
                dp[i] = dp[i - 1] + 1
            # 设置字符与索引键值对
            map[s[i]] = i
        # 最后拉通看一遍最大值
        return max(dp)
</code></pre>
<p>思路3：隔板法</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s):
        # 特判
        l = len(s)
        if l &lt; 2:
            return l
        # 隔板法
        # key:字符，val 出现的索引
        map = dict()
        point = 0
        res = 1
        for i in range(l):
            # 关键1：map[s[i]] &gt;= point，等于是可以的
            if s[i] in map and map[s[i]] &gt;= point:
                # 先把隔板向后移动一位
                point = map[s[i]] + 1
            # 然后记录最长不重复子串的长度
            res = max(res, i - point + 1)
            # 关键2：无论如何都更新位置
            map[s[i]] = i
        return res
</code></pre>
<p>参考资料：<a href="https://www.zybuluo.com/liweiwei1419/note/1394415">LeetCode 第 3 题：最长不重复字符串</a>。</p>
<h3 id="49">第 49 题：丑数</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/58/">丑数</a>，<a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>把只包含因子 $2$、$3$ 和 $5$ 的数称作<a href="https://cuijiahua.com/blog/tag/%e4%b8%91%e6%95%b0/">丑数</a>（Ugly Number）。</p>
<p>例如 $6$、$8$ 都是<a href="https://cuijiahua.com/blog/tag/%e4%b8%91%e6%95%b0/">丑数</a>，但 $14$ 不是，因为它包含因子 $7$。 </p>
<p>求按从小到大的顺序的第 $N$ 个丑数。</p>
<p>样例：</p>
<p>输入：5</p>
<p>输出：5</p>
<p><strong>注意</strong>：习惯上我们把 $1$ 当做是第一个丑数。</p>
</blockquote>
<p>同 LeetCode 第 264 题，题解传送门：<a href="https://www.zybuluo.com/liweiwei1419/note/1394376">LeetCode 上的丑数问题</a>。</p>
<p>思路：所谓的一个数 $m$ 是另一个数 $n$ 的因子，是指 $n$ 能被 $m$ 整除，也就是 $n\%m==0$ 成立。根据丑数的定义，丑数只能被 $2$、$3$ 和 $5$ 整除。根据丑数的定义，丑数应该是另一个丑数乘以 $2$、$3$ 或者 $5$ 的结果（$1$除外）。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以 $2$、$3$ 或者 $5$ 得到的。</p>
<p>这个思路的关键问题在于怎样保证数组里面的丑数是排好序的。对乘以 $2$ 而言，肯定存在某一个丑数 $T2$，排在它之前的每一个丑数乘以 $2$ 得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘以乘以 $2$ 得到的结果都会太大。我们只需要记下这个丑数的位置，同时每次生成新的丑数的时候，去更新这个 $T2$。对乘以 $3$ 和 $5$ 而言，也存在着同样的 $T3$ 和 $T5$。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def GetUglyNumber_Solution(self, index):
        # write code here
        if index &lt; 7:
            return index
        res = [1, 2, 3, 4, 5, 6]
        t2, t3, t5 = 3, 2, 1
        for i in range(6, index):
            res.append(min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5)))
            while res[t2] * 2 &lt;= res[i]:
                t2 += 1
            while res[t3] * 3 &lt;= res[i]:
                t3 += 1
            while res[t5] * 5 &lt;= res[i]:
                t5 += 1
        return res[index - 1]
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">public class Solution2 {

    // 1、2、3、4、5、6 都是丑数
    public int GetUglyNumber_Solution(int index) {
        if (index &lt; 7) {
            return index;
        }

        // 状态的定义：第 i 个丑数的最小值，从 0 开始计算
        int[] dp = new int[index];
        dp[0] = 1;

        int t2 = 0;
        int t3 = 0;
        int t5 = 0;

        // 注意： i 从 1 开始
        for (int i = 1; i &lt; index; i++) {
            dp[i] = min3(dp[t2] * 2, dp[t3] * 3, dp[t5] * 5);
            if (dp[i] == dp[t2] * 2) {
                t2++;
            }
            if (dp[i] == dp[t3] * 3) {
                t3++;
            }
            if (dp[i] == dp[t5] * 5) {
                t5++;
            }
        }
        // System.out.println(Arrays.toString(dp));
        return dp[index - 1];
    }

    private int min3(int n1, int n2, int n3) {
        return Integer.min(Integer.min(n1, n2), n3);
    }

    public static void main(String[] args) {
        Solution2 solution2 = new Solution2();
        // 1 2 3 4 5 6 8 9 10 12 15 16 18 20 24
        // [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]
        int getUglyNumberSolution = solution2.GetUglyNumber_Solution(15);
    }
}
</code></pre>
<h3 id="50-1">第 50-1 题：字符串中第一个只出现一次的字符</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/59/">字符串中第一个只出现一次的字符</a>。</p>
<blockquote>
<p>在字符串中找出第一个只出现一次的字符。</p>
<p>如输入<code>"abaccdeff"</code>，则输出<code>b</code>。</p>
<p>如果字符串中不存在只出现一次的字符，返回#字符。</p>
<p>样例：</p>
<p>输入：<code>"abaccdeff"</code></p>
<p>输出：<code>'b'</code></p>
</blockquote>
<p>同 LeetCode 第 387 题，传送门：<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string">字符串中的第一个唯一字符</a>。</p>
<p>思路：特别容易想到的思路，就是统计词频，统计词频可以用哈希表，也可以用数组。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    def firstNotRepeatingChar(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        if len(s) &lt; 1:
            return '#'

        counter = [0 for _ in range(256)]
        for alpha in s:
            counter[ord(alpha)] += 1
        for alpha in s:
            if counter[ord(alpha)] == 1:
                return alpha
        # 要注意：如果是 &quot;aabbcc&quot; 这种所有的字符都出现不止 1 次，
        # 就按照题意，返回 '#'
        return '#'
</code></pre>
<h3 id="50-2">第 50-2 题：字符流中第一个不重复的字符</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/60/">字符流中第一个只出现一次的字符</a>，<a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。</p>
<p>例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。</p>
<p>当从该字符流中读出前六个字符”google”时，第一个只出现一次的字符是’l’。</p>
<p>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<p>样例：</p>
<p>输入：<code>"google"</code></p>
<p>输出：<code>"ggg#ll"</code></p>
<p>解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</p>
</blockquote>
<p>Python 代码：使用辅助数组，做字母频数统计</p>
<pre><code class="language-python">class Solution:

    def __init__(self):
        self.chars = [0 for _ in range(256)]
        self.strs = []

    def firstAppearingOnce(self):
        &quot;&quot;&quot;
        :rtype: str
        &quot;&quot;&quot;
        for char in self.strs:
            if self.chars[ord(char)] == 1:
                return char
        return '#'

    def insert(self, char):
        &quot;&quot;&quot;
        :type char: str
        :rtype: void
        &quot;&quot;&quot;
        self.chars[ord(char)] += 1
        self.strs.append(char)
</code></pre>
<p>Java 代码：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 50-2 题：字符流中第一个不重复的字符-1" src="http://upload-images.jianshu.io/upload_images/414598-71ca063009151d28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 50-2 题：字符流中第一个不重复的字符-2" src="http://upload-images.jianshu.io/upload_images/414598-18e7146a44d8e4d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:
    h = {}
    r = []
    def firstAppearingOnce(self):
        while len(Solution.r):
            if Solution.h[Solution.r[0]] == 1:
                return Solution.r[0]
            Solution.r = Solution.r[1:]
        return '#'

    def insert(self, char):
        Solution.h[char] = Solution.h.get(char, 0) + 1
        if Solution.h[char] == 1:
            Solution.r.append(char)
</code></pre>
<p>作者：applezjm
链接：https://www.acwing.com/activity/content/code/content/19320/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>（本节完）</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
