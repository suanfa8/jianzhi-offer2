<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 31-40 题 - 《剑指 Offer》（第 2 版）</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u300a\u5251\u6307 Offer\u300b\uff08\u7b2c 2 \u7248\uff09 \u9898\u89e3\uff08Python \u8bed\u8a00\u5b9e\u73b0\uff09\u7b2c 31-40 \u9898";
    var mkdocs_page_input_path = "31-40.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> 《剑指 Offer》（第 2 版）</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">首页</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 1 - 20 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../03/">剑指 Offer 03. 数组中重复的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../04/">剑指 Offer 04. 二维数组中的查找</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../05/">剑指 Offer 05. 替换空格</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../06/">剑指 Offer 06. 从尾到头打印链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../07/">剑指 Offer 07. 重建二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../08/">剑指 Offer 08. 二叉树的下一个结点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../09/">剑指 Offer 09. 用两个栈实现队列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../10-1/">剑指 Offer 10- I. 斐波那契数列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../10-2/">剑指 Offer 10- II. 青蛙跳台阶问题</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../11/">剑指 Offer 11. 旋转数组的最小数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../12/">剑指 Offer 12. 矩阵中的路径</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../13/">剑指 Offer 13. 机器人的运动范围</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../14-1/">剑指 Offer 14- I. 剪绳子</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../14-2/">剑指 Offer 14- II. 剪绳子 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../15/">剑指 Offer 15. 二进制中1的个数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../16/">剑指 Offer 16. 数值的整数次方</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../17/">剑指 Offer 17. 打印从1到最大的n位数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../18/">剑指 Offer 18. 删除链表的节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../19/">剑指 Offer 19. 正则表达式匹配</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../20/">剑指 Offer 20. 表示数值的字符串</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 21 - 40 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../21/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../22/">剑指 Offer 22. 链表中倒数第k个节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../24/">剑指 Offer 24. 反转链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../25/">剑指 Offer 25. 合并两个排序的链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../26/">剑指 Offer 26. 树的子结构</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../27/">剑指 Offer 27. 二叉树的镜像</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../28/">剑指 Offer 28. 对称的二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../29/">剑指 Offer 29. 顺时针打印矩阵</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../30/">剑指 Offer 30. 包含min函数的栈</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../31/">剑指 Offer 31. 栈的压入、弹出序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-1/">剑指 Offer 32 - I. 从上到下打印二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-2/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../32-3/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../33/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../34/">剑指 Offer 34. 二叉树中和为某一值的路径</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../35/">剑指 Offer 35. 复杂链表的复制</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../36/">剑指 Offer 36. 二叉搜索树与双向链表</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../37/">剑指 Offer 37. 序列化二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../38/">剑指 Offer 38. 字符串的排列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../39/">剑指 Offer 39. 数组中出现次数超过一半的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../40/">剑指 Offer 40. 最小的k个数</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 41 - 60 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../41/">剑指 Offer 41. 数据流中的中位数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../42/">剑指 Offer 42. 连续子数组的最大和</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../43/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../44/">剑指 Offer 44. 数字序列中某一位的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../45/">剑指 Offer 45. 把数组排成最小的数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../46/">剑指 Offer 46. 把数字翻译成字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../47/">剑指 Offer 47. 礼物的最大价值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../48/">剑指 Offer 48. 最长不含重复字符的子字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../49/">剑指 Offer 49. 丑数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../50/">剑指 Offer 50. 第一个只出现一次的字符</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../51/">剑指 Offer 51. 数组中的逆序对</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../52/">剑指 Offer 52. 两个链表的第一个公共节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../53/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../53-2/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../54/">剑指 Offer 54. 二叉搜索树的第k大节点</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../55/">剑指 Offer 55 - I. 二叉树的深度</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../55-2/">剑指 Offer 55 - II. 平衡二叉树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../56/">剑指 Offer 56 - I. 数组中数字出现的次数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../56-2/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../57/">剑指 Offer 57. 和为s的两个数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../57-2/">剑指 Offer 57 - II. 和为s的连续正数序列</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../58/">剑指 Offer 58 - I. 翻转单词顺序</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../58-2/">剑指 Offer 58 - II. 左旋转字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../59/">剑指 Offer 59 - I. 滑动窗口的最大值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../59-2/">剑指 Offer 59 - II. 队列的最大值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../60/">剑指 Offer 60. n个骰子的点数</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">第 61 - 68 题</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../61/">剑指 Offer 61. 扑克牌中的顺子</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../62/">剑指 Offer 62. 圆圈中最后剩下的数字</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../63/">剑指 Offer 63. 股票的最大利润</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../64/">剑指 Offer 64. 求1+2+…+n</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../65/">剑指 Offer 65. 不用加减乘除做加法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../66/">剑指 Offer 66. 构建乘积数组</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../67/">剑指 Offer 67. 把字符串转换成整数</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../68/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../68-2/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">《剑指 Offer》（第 2 版）</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 31-40 题</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="offer-2-python-31-40">《剑指 Offer》（第 2 版） 题解（Python 语言实现）第 31-40 题</h1>
<h3 id="35">第 35 题：复杂链表的复制</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/89/">复杂链表的复刻</a>，<a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>请实现一个函数可以复制一个复杂链表。</p>
<p>在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者 null 。</p>
</blockquote>
<p>分析：一些细节要考虑到，特别是空结点的判断，以下两种方法都要遍历链表一遍以上，即遍历链表一遍是不够的。</p>
<p>思路1：有点巧妙，穿针引线，新旧断开。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None
        self.random = None


class Solution(object):
    def copyRandomList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if head is None:
            return None

        # 第 1 步：根据 next 指针复制出一个新旧合一的链表
        cur_node = head
        while cur_node:
            # 先暂存 cur_node 的 next_node 下一次遍历要用
            next_node = cur_node.next

            new_node = ListNode(cur_node.val)

            cur_node.next = new_node
            new_node.next = next_node
            # 指针遍历到下一个结点
            cur_node = next_node
        # 第 2 步：根据旧结点 random 指针，给新结点的 random 指针做出正确的指向
        cur_node = head
        while cur_node:
            new_node = cur_node.next
            # 同样要先暂存 cur_node.next_node
            next_node = new_node.next
            # 要记得做非空判断，因为题目中说了 random 有可能为空
            new_node.random = cur_node.random.next if cur_node.random else None
            cur_node = next_node

        # 第 3 步：旧结点和新结点分离（拆分链表）
        cur_node = head
        res = cur_node.next
        while cur_node:
            new_node = cur_node.next
            # 同样要先暂存下一个结点
            next_node = new_node.next
            # 恢复原始结点
            cur_node.next = new_node.next
            # 恢复拷贝结点
            # 这里也要同样注意空指针的问题，克隆结点的最后一个结点的下一个结点是 null
            new_node.next = next_node.next if next_node else None
            cur_node = next_node
        return res
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}

public class Solution {
    public RandomListNode Clone(RandomListNode pHead) {
        // 极端情况，一定要写先出来
        if (pHead == null) {
            return null;
        }

        RandomListNode curNode = pHead;
        // 第 1 步：根据 next 指针复制出一个新旧合一的链表
        // 此时，奇数索引（从 1 开始计算）的结点是旧的结点，偶数索引的结点是新的结点
        RandomListNode nextNode;
        RandomListNode copyNode;
        while (curNode != null) {
            nextNode = curNode.next;
            copyNode = new RandomListNode(curNode.label);
            curNode.next = copyNode;
            copyNode.next = nextNode;
            curNode = nextNode;
        }

        // 第 2 步：根据旧结点 random 指针，给新结点的 random 指针做出正确的指向
        // 指针复位到起始结点
        curNode = pHead;
        while (curNode != null) {
            copyNode = curNode.next;
            nextNode = copyNode.next;
            // 特别注意
            // 特别注意
            // 特别注意：有的结点很可能 random 的指向为空（题目中明确说明）
            // 所以：只要遇到 next 引用的时候，一定要注意判断是否为空
            copyNode.random = curNode.random == null ? null : curNode.random.next;
            curNode = nextNode;
        }

        // 第 3 步：旧结点和新结点分离（拆分链表）
        curNode = pHead;
        RandomListNode res = pHead.next;
        while (curNode != null) {
            copyNode = curNode.next;
            nextNode = copyNode.next;
            // 恢复原始结点
            curNode.next = copyNode.next;
            // 恢复拷贝结点
            // 这里也要同样注意空指针的问题，克隆结点的最后一个结点的下一个结点是 null
            copyNode.next = copyNode.next == null ? null : copyNode.next.next;
            curNode = nextNode;
        }
        return res;
    }
}
</code></pre>
<p>C++ 写法：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 35 题：复杂链表的复制" src="http://upload-images.jianshu.io/upload_images/414598-84ee91641c69db44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Java 版本里面还有一个网友的写法。</p>
<p>思路2：使用哈希表，复制出随机访问的指针。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None
        self.random = None


class Solution(object):
    def copyRandomList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if head is None:
            return None
        map = dict()
        dummy_node = ListNode(-1)
        # p 指针用于新链表的 next 指针赋值
        p = dummy_node

        # 遍历一次链表，做两件事
        # 1、复制结点
        # 2、只管 next 指针
        cur_node = head
        while cur_node:
            new_node = ListNode(cur_node.val)
            # 把新旧结点的对应关系放在一个 map 里
            map[cur_node] = new_node
            cur_node = cur_node.next

            p.next = new_node
            p = new_node

        # 接下来做随机指针的复制
        for old_node, new_node in map.items():
            # 要记得判断是否为空，否则 None 不能作为 map  key
            if old_node.random:
                new_node.random = map[old_node.random]
        return dummy_node.next
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">public class Solution3 {
    public RandomListNode Clone(RandomListNode pHead) {
        Map&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;();
        RandomListNode curNode = pHead;
        // 体会这里设置虚拟头结点的必要性
        RandomListNode dummyNode = new RandomListNode(-1);
        RandomListNode p = dummyNode;
        // 完成复制 next 结点，并且将对应关系放入 Hash 表
        while (curNode != null) {
            RandomListNode newNode = new RandomListNode(curNode.label);
            map.put(curNode, newNode);
            curNode = curNode.next;
            p.next = newNode;
            p = newNode;
        }
        // 完成复制链表的 random 指针的赋值
        Set&lt;Map.Entry&lt;RandomListNode, RandomListNode&gt;&gt; entrySet = map.entrySet();
        for (Map.Entry&lt;RandomListNode, RandomListNode&gt; entry : entrySet) {
            entry.getValue().random = map.get(entry.getKey().random);
        }
        return dummyNode.next;
    }
}
</code></pre>
<p>Java 代码：特别注意：在复制“指针”的时候，对空对象的判定，画图是十分关键的。</p>
<pre><code class="language-java">class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}

public class Solution {
    public RandomListNode Clone(RandomListNode pHead) {
        // 极端情况，一定要写先出来
        if (pHead == null) {
            return null;
        }

        RandomListNode curNode = pHead;
        // 第 1 步：根据 next 指针复制出一个新旧合一的链表
        // 此时，奇数索引（从 1 开始计算）的结点是旧的结点，偶数索引的结点是新的结点
        RandomListNode nextNode;
        RandomListNode copyNode;
        while (curNode != null) {
            nextNode = curNode.next;
            copyNode = new RandomListNode(curNode.label);
            curNode.next = copyNode;
            copyNode.next = nextNode;
            curNode = nextNode;
        }

        // 第 2 步：根据旧结点 random 指针，给新结点的 random 指针做出正确的指向
        // 指针复位到起始结点
        curNode = pHead;
        while (curNode != null) {
            copyNode = curNode.next;
            nextNode = copyNode.next;
            // 特别注意
            // 特别注意
            // 特别注意：有的结点很可能 random 的指向为空（题目中明确说明）
            // 所以：只要遇到 next 引用的时候，一定要注意判断是否为空
            copyNode.random = curNode.random == null ? null : curNode.random.next;
            curNode = nextNode;
        }

        // 第 3 步：旧结点和新结点分离（拆分链表）
        curNode = pHead;
        RandomListNode res = pHead.next;
        while (curNode != null) {
            copyNode = curNode.next;
            nextNode = copyNode.next;
            // 恢复原始结点
            curNode.next = copyNode.next;
            // 恢复拷贝结点
            // 这里也要同样注意空指针的问题，克隆结点的最后一个结点的下一个结点是 null
            copyNode.next = copyNode.next == null ? null : copyNode.next.next;
            curNode = nextNode;
        }
        return res;
    }
}
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * 使用 Hash 表的方式
 *
 * @author liwei
 */
public class Solution2 {
    public RandomListNode Clone(RandomListNode pHead) {
        Map&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;();
        RandomListNode curNode = pHead;
        // 体会这里设置虚拟头结点的必要性
        RandomListNode dummyNode = new RandomListNode(-1);
        RandomListNode p = dummyNode;
        // 完成复制 next 结点，并且将对应关系放入 Hash 表
        while (curNode != null) {
            RandomListNode newNode = new RandomListNode(curNode.label);
            map.put(curNode, newNode);
            curNode = curNode.next;
            p.next = newNode;
            p = newNode;
        }
        // 完成复制链表的 random 指针的赋值
        Set&lt;Map.Entry&lt;RandomListNode, RandomListNode&gt;&gt; entrySet = map.entrySet();
        for (Map.Entry&lt;RandomListNode, RandomListNode&gt; entry : entrySet) {
            entry.getValue().random = map.get(entry.getKey().random);
        }
        return dummyNode.next;
    }
}
</code></pre>
<h3 id="36">第 36 题：二叉搜索树与双向链表（典型递归问题）</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/87/">二叉搜索树与双向链表</a>，<a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p>
<p>要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>需要返回双向链表最左侧的节点。</li>
</ul>
<p>例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。</p>
<p><img alt="《剑指 Offer （第 2 版）》第 36 题：二叉搜索树与双向链表（典型递归问题）-1" src="http://upload-images.jianshu.io/upload_images/414598-6e14690da0349ad2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
</blockquote>
<p>思路：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 36 题：二叉搜索树与双向链表（典型递归问题）-2" src="http://upload-images.jianshu.io/upload_images/414598-a46100ffb72f4d38.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>分析：参考解答有一定价值，要好好研究一下。画图就清楚解法了。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def convert(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        if root is None:
            return None
        head, _ = self.__dfs(root)

        return head

    def __dfs(self, root):
        &quot;&quot;&quot;
        返回双向链表的两端
        &quot;&quot;&quot;
        # 如果这个结点是叶子结点
        if root.left is None and root.right is None:
            return (root, root)

        # 如果有左孩子，还有右边孩子
        if root.left and root.right:
            ll, lr = self.__dfs(root.left)
            rl, rr = self.__dfs(root.right)
            # 下面穿针引线
            lr.right = root
            root.left = lr
            root.right = rl
            rl.left = root
            return (ll, rr)

        # 走到这里，就是二者之一为空
        if root.left:
            ll, lr = self.__dfs(root.left)
            lr.right = root
            root.left = lr
            return (ll, root)

        if root.right:
            rl, rr = self.__dfs(root.right)
            root.right = rl
            rl.left = root
            return (root, rr)
</code></pre>
<p>C++ 代码：返回一个 pair</p>
<p><img alt="《剑指 Offer （第 2 版）》第 36 题：二叉搜索树与双向链表（典型递归问题）-3" src="http://upload-images.jianshu.io/upload_images/414598-95be5f9cc1e22889.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Java 代码：</p>
<pre><code class="language-java">class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}

public class Solution {

    private TreeNode linkedListTail;
    private TreeNode res;

    public TreeNode Convert(TreeNode pRootOfTree) {
        convert(pRootOfTree);
        return res;
    }

    /**
     * 中序遍历
     *
     * @param root
     */
    private void convert(TreeNode root) {
        if (root == null) {
            return;
        }
        convert(root.left);
        // 中序遍历真正做事情的地方
        if (linkedListTail == null) { // 对应刚开始的时候
            linkedListTail = root;
            // 在最左边的地方记录需要返回的双向链表的根结点
            res = root;
        } else {
            linkedListTail.right = root;
            root.left = linkedListTail;
            linkedListTail = root;
        }
        convert(root.right);
    }
}
</code></pre>
<p>Python 代码：</p>
<pre><code class="language-python">class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def __init__(self):
        self.linked_list_tail = None
        self.res = None

    def convert(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        self.__dfs(root)
        return self.res

    # 中序遍历
    def __dfs(self, root):
        if root is None:
            return
        self.__dfs(root.left)

        if self.linked_list_tail is None:
            self.linked_list_tail = root
            self.res = root
        else:
            self.linked_list_tail.right = root
            root.left = self.linked_list_tail
            self.linked_list_tail = root
        self.__dfs(root.right)
</code></pre>
<p>Java 代码：分治法</p>
<pre><code class="language-java">public class Solution2 {
    public TreeNode convert(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode left = rightMost(root.left);
        TreeNode right = leftMost(root.right);
        convert(root.left);
        convert(root.right);
        if (left != null) {
            left.right = root;
        }
        root.left = left;
        if (right != null) {
            right.left = root;
        }
        root.right = right;

        // 最后返回最左边的结点
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }

    TreeNode leftMost(TreeNode root) {
        if (root == null) {
            return null;
        }
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }

    TreeNode rightMost(TreeNode root) {
        if (root == null) {
            return null;
        }
        while (root.right != null) {
            root = root.right;
        }
        return root;
    }
}
</code></pre>
<p>C++ 代码：</p>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* convert(TreeNode* root) {
        if (!root) return root;
        stack&lt;TreeNode*&gt; st;
        while (root){
            st.push(root);
            root = root-&gt;left;
        }
        TreeNode* ans = st.top();
        TreeNode* last = NULL;
        while (!st.empty()){
            TreeNode* tmp = st.top();
            st.pop();
            if (!last) last = tmp;
            else {
                last-&gt;right = tmp;
                tmp-&gt;left = last;
                last = tmp;
            }
            tmp = tmp-&gt;right;
            while (tmp){
                st.push(tmp);
                tmp = tmp-&gt;left;
            }
        }
        return ans;
    }
};
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode convert(TreeNode root) {
        if (root == null) return null;
        TreeNode dummy = new TreeNode(-1);
        TreeNode pre = dummy;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        while (root != null || stack.size() != 0){
            while (root != null){
                stack.push(root);
                root = root.left;
            }
            if (stack.size() != 0){
                TreeNode node = stack.pop();
                pre.right = node;
                node.left = pre;
                pre = pre.right;
                root = node.right;
            }
        }
        dummy.right.left = null;
        dummy = dummy.right;
        return dummy;
    }
}
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}

public class Solution {

    private TreeNode linkedListTail;
    private TreeNode res;

    public TreeNode Convert(TreeNode pRootOfTree) {
        convert(pRootOfTree);
        return res;
    }

    /**
     * 中序遍历
     *
     * @param root
     */
    private void convert(TreeNode root) {
        if (root == null) {
            return;
        }
        convert(root.left);
        // 中序遍历真正做事情的地方
        if (linkedListTail == null) {
            linkedListTail = root;
            // 在最左边的地方记录需要返回的双向链表的根结点
            res = root;
        } else {
            linkedListTail.right = root;
            root.left = linkedListTail;
            linkedListTail = root;
        }
        convert(root.right);
    }
}
</code></pre>
<p>参考资料：https://www.nowcoder.com/questionTerminal/947f6eb80d944a84850b0538bf0ec3a5</p>
<h3 id="37">第 37 题：序列化二叉树</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/46/">序列化二叉树</a>，<a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。</p>
<p>样例：</p>
<p>你可以序列化如下的二叉树
<code>8
   / \
 12  2
       / \
     6   4</code>
为：<code>"[8, 12, 2, null, null, 6, 4, null, null, null, null]"</code></p>
<p><strong>注意</strong>:</p>
<ul>
<li>以上的格式是 AcWing 序列化二叉树的方式，你不必一定按照此格式，所以可以设计出一些新的构造方式。</li>
</ul>
</blockquote>
<p>分析：总之就是前序遍历。因为“前序遍历”有很好的性质：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 37 题：序列化二叉树" src="http://upload-images.jianshu.io/upload_images/414598-bc8ea3379cd2ad2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>说明：根据上面的序列化规则，上图中的二叉树被序列化成字符串 <code>"1，2，4，$，$，$，3，5，$，$，6，$，$"</code> 。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution:

    # 前序遍历
    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        &quot;&quot;&quot;

        res = ''
        if root is None:
            return '! '
        res += str(root.val)
        res += ' '
        res += self.serialize(root.left)
        res += self.serialize(root.right)
        return res

    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        &quot;&quot;&quot;
        arr = data.split(' ')
        return self.__helper(arr)

    def __helper(self, arr):
        if arr:
            top = arr.pop(0)
            if top != '!':
                root = TreeNode(int(top))
                root.left = self.__helper(arr)
                root.right = self.__helper(arr)
                return root
            else:
                return None
</code></pre>
<p>Python 代码：序列化时候，不用递归，用栈的写法</p>
<pre><code class="language-python">class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:

    # 前序遍历
    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        &quot;&quot;&quot;

        res = []
        if root is None:
            return '!'

        stack = [root]
        while stack:
            top = stack.pop()
            if top is None:
                res.append('!')
            else:
                stack.append(top.right)
                stack.append(top.left)
                res.append(str(top.val))
        return ' '.join(res)

    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        &quot;&quot;&quot;
        queue = data.split(' ')
        return self.__build_tree(queue)

    def __build_tree(self, queue):
        if queue:
            top = queue.pop(0)
            if top != '!':
                root = TreeNode(int(top))
                root.left = self.__build_tree(queue)
                root.right = self.__build_tree(queue)
                return root
            else:
                return None
        # 如果 queue 为空，就什么都不做
</code></pre>
<p>Java 代码：序列化：前序遍历二叉树存入字符串中，反序列化：根据前序遍历重建二叉树</p>
<pre><code class="language-java">import java.util.LinkedList;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {

    /**
     * 序列化一棵二叉树（其实就是前序遍历）
     * @param root
     * @return
     */
    public String serialize(TreeNode root) {
        if (root == null) {
            return &quot;$,&quot;;
        }
        StringBuilder sb = new StringBuilder(root.val + &quot;,&quot;);
        sb.append(serialize(root.left));
        sb.append(serialize(root.right));
        return sb.toString();
    }

    // 反序列化一棵二叉树
    public TreeNode deserialize(String str) {
        String[] strArr = str.split(&quot;,&quot;);
        LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();
        for (String s : strArr) {
            queue.addLast(s);
        }
        return preOrder(queue);
    }

    // 使用队列就实现了迭代器的功能
    private TreeNode preOrder(LinkedList&lt;String&gt; queue) {
        String s = queue.removeFirst();
        if (!&quot;$&quot;.endsWith(s)) {
            TreeNode newNode = new TreeNode(Integer.parseInt(s));
            newNode.left = preOrder(queue);
            newNode.right = preOrder(queue);
            // 理解将新创建的结点返回回去的必要性
            return newNode;
        }
        // 是 &quot;$&quot; 就返回空指针，注意这里的递归方法，会把空指针接在原来的树节点上
        return null;
    }
}
</code></pre>
<p>另一种写法：</p>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.LinkedList;

// 前序遍历
public class Solution2 {

    String Serialize(TreeNode root) {
        StringBuilder stringBuilder = new StringBuilder();
        preOrder(root, stringBuilder);
        return stringBuilder.toString();
    }

    // 上面函数的辅助函数
    private void preOrder(TreeNode node, StringBuilder stringBuilder) {
        if (node == null) {
            stringBuilder.append(&quot;#&quot;);
            stringBuilder.append(&quot;,&quot;);
            return;
        }
        stringBuilder.append(node.val);
        stringBuilder.append(&quot;,&quot;);
        preOrder(node.left, stringBuilder);
        preOrder(node.right, stringBuilder);
    }

    TreeNode Deserialize(String str) {
        String[] strings = str.split(&quot;,&quot;);
        int size = strings.length;
        System.out.println(size);
        LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; size; i++) {
            queue.addLast(strings[i]);
        }
        return inOrderGenerate(queue);
    }

    private TreeNode inOrderGenerate(LinkedList&lt;String&gt; queue) {
        if (queue.isEmpty()) {
            return null;
        }
        String s = queue.removeFirst();
        if (!&quot;#&quot;.equals(s)) {
            TreeNode root = new TreeNode(Integer.parseInt(s));
            root.left = inOrderGenerate(queue);
            root.right = inOrderGenerate(queue);
            return root;
        }
        return null;
    }
}
</code></pre>
<p>C++ 代码：</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string res;
        dfs_s(root, res);
        return res;
    }

    void dfs_s(TreeNode *root, string &amp;res)
    {
        if (!root) {
            res += &quot;null &quot;;
            return;
        }
        res += to_string(root-&gt;val) + ' ';
        dfs_s(root-&gt;left, res);
        dfs_s(root-&gt;right, res);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs_d(data, u);
    }

    TreeNode* dfs_d(string &amp;data, int &amp;u)
    {
        if (u == data.size()) return NULL;
        int k = u;
        while (data[k] != ' ') k ++ ;
        if (data[u] == 'n') {
            u = k + 1;
            return NULL;
        }
        int val = 0;
        for (int i = u; i &lt; k; i ++ ) val = val * 10 + data[i] - '0';
        u = k + 1;
        auto root = new TreeNode(val);

        root-&gt;left = dfs_d(data, u);
        root-&gt;right = dfs_d(data, u);

        return root;
    }
};
</code></pre>
<p>作者：yxc
链接：https://www.acwing.com/activity/content/code/content/20710/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="38">第 38 题：字符串的排列（重要，回溯）</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/47/">数字排列</a>，<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入一组数字（可能包含重复数字），输出其所有的排列方式。</p>
<p>样例：</p>
<p>输入：<code>[1,2,3]</code></p>
<p>输出：
<code>[
     [1,2,3],
     [1,3,2],
     [2,1,3],
     [2,3,1],
     [3,1,2],
     [3,2,1]
   ]</code></p>
</blockquote>
<p>分析：八皇后问题根据排列组合来求解，关键是判定不符合要求的解。回溯：时间复杂度是 $O(n!)$。</p>
<p>题目描述：跟 LeetCode 47. Permutations II 一模一样，都是不重复的全排列。注意区分上一道题 LeetCode 46. Permutations 。</p>
<p>Python 代码：学会使用位运算判重</p>
<pre><code class="language-python">class Solution:
    def permutation(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &quot;&quot;&quot;

        l = len(nums)
        res = []
        if l == 0:
            return res
        # 因为含有重复数组，所以先排序
        nums.sort()
        path = [0 for _ in range(l)]
        self.__dfs(nums, 0, 0, path, 0, res)

        return res

    def __dfs(self, nums, index, start, path, state, res):
        if index == len(nums):
            res.append(path[:])
            return

        if index == 0 or nums[index] != nums[index - 1]:
            start = 0

        for i in range(start, len(nums)):
            if (state &gt;&gt; i &amp; 1) == 0:
                path[i] = nums[index]
                self.__dfs(nums, index + 1, i + 1, path, state + (1 &lt;&lt; i), res)
</code></pre>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Stack;

class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }
}

public class Solution {
    // 使用搜索的策略可以完成
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) {
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        Stack&lt;Integer&gt; pre = new Stack&lt;&gt;();
        findPath(root, target, pre, res);
        return res;
    }

    private void findPath(TreeNode root, int target, Stack&lt;Integer&gt; pre, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res) {
        if (root == null || root.val &gt; target) {
            return;
        }
        // 注意：题目中问的是到叶子结点
        if (root.val == target &amp;&amp; root.left == null &amp;&amp; root.right == null) {
            pre.add(root.val);
            res.add(new ArrayList&lt;&gt;(pre));
            pre.pop();
            return;
        }
        assert root.val &lt; target &amp;&amp; root != null;
        pre.add(root.val);
        findPath(root.left, target - root.val, pre, res);
        findPath(root.right, target - root.val, pre, res);
        pre.pop();
    }

    public static void main(String[] args) {
        TreeNode node1 = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(4);
        TreeNode node8 = new TreeNode(8);
        TreeNode node7 = new TreeNode(7);

        node1.left = node2;
        node1.right = node3;

        node2.left = node4;
        node2.right = node8;

        node3.left = node7;

        Solution solution = new Solution();
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath = solution.FindPath(node1, 11);
        System.out.println(findPath);
    }
}
</code></pre>
<h3 id="39">第 39 题：数组中超过一半的数字</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/48/"> 数组中出现次数超过一半的数字</a>，<a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>假设数组非空，并且一定存在满足条件的数字。</p>
<p><strong>思考题</strong>：</p>
<ul>
<li>假设要求只能使用 $O(n)$ 的时间和额外 $O(1)$ 的空间，该怎么做呢？</li>
</ul>
<p>样例：</p>
<p>输入：<code>[1,2,1,1,3]</code></p>
<p>输出：1</p>
</blockquote>
<p>思路1：首先排序，中间那个数，一定是要求的。</p>
<p>思路2：将首次出现的数 <code>count + 1</code>，与之后的数进行比较，相等则 <code>+1</code>，否则 <code>-1</code>，最后进行校验是否超过长度的一半。数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加 $1$；如果下一个数字和我们之前保存的数字不同，则次数减 $1$ 。如果次数为零，我们需要保存下一个数字，并把次数设为 $1$。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为 $1$ 时对应的数字。</p>
<p>Python 代码：</p>
<pre><code class="language-python"># -*- coding:utf-8 -*-
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        res = numbers[0]
        times = 1
        for num in numbers[1:]:
            if times == 0:
                res = num
                times = 1
            elif res == num:
                times += 1
            else:
                times -= 1
        # 验证 res 是不是超过一半
        times = 0
        for num in numbers:
            if num == res:
                times += 1
        return res if times &gt; len(numbers) // 2 else 0

</code></pre>
<p>说明：“假设数组非空，并且一定存在满足条件的数字”的时候，就不用做最后一步的判断。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution(object):
    def moreThanHalfNum_Solution(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;

        l = len(nums)
        if l == 1:
            return nums[0]

        num = nums[0]
        times = 1
        for i in range(1, l):
            # 注意分类讨论的顺序，先看次数是不是 0
            # 以下的 3 种情况是互斥的
            if times == 0:
                num = nums[i]
                times += 1
            elif num == nums[i]:
                times += 1
            else:
                times -= 1
        return num
</code></pre>
<p>C++ 代码：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 39 题：数组中超过一半的数字" src="http://upload-images.jianshu.io/upload_images/414598-93b5c3f547450ebc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>Java 代码：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    //
    // {1,2,3,2,2,2,5,4,2} 9 4
    // {1,2,3,2,2,2,5,4} 8 4
    public int MoreThanHalfNum_Solution(int[] array) {
        int len = array.length;
        if (len == 0) {
            return 0;
        }
        Arrays.sort(array);
        int target = array[len / 2];
        int count = 0;
        for (int i = 0; i &lt; len; i++) {
            if (array[i] == target) {
                count++;
            }
        }
        if (count &gt; len / 2) {
            return target;
        }
        return 0;
    }


    public static void main(String[] args) {
        int[] nums = new int[]{1, 2, 3, 2, 2, 2, 5, 4, 2};
        // [1,2,3,2,4,2,5,2,3]
        Solution solution = new Solution();
        int moreThanHalfNum_solution = solution.MoreThanHalfNum_Solution(nums);
        System.out.println(moreThanHalfNum_solution);
    }
}
</code></pre>
<h3 id="40-k">第 40 题：最小的 K 个数</h3>
<p>传送门：<a href="https://www.acwing.com/problem/content/49/">最小的k个数</a>，<a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">牛客网 online judge 地址</a>。</p>
<blockquote>
<p>输入 $n$ 个整数，找出其中最小的 $k$ 个数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数据保证 k 一定小于等于输入数组的长度;</li>
<li>输出数组内元素请按从小到大顺序排序;</li>
</ul>
<p>样例：</p>
<p>输入：<code>[1,2,3,4,5,6,7,8]</code>, <code>k=4</code></p>
<p>输出：<code>[1,2,3,4]</code></p>
</blockquote>
<p>分析：最简单的思路就是排个序，然后取出前 $k$ 个元素，不过时间复杂度是 $O(n\log n)$，$n$ 为数组的长度。 </p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution(object):
    def getLeastNumbers_Solution(self, input, k):
        size = len(input)
        if size == 0:
            return []
        if k == size:
            return sorted(input)
        return sorted(input)[:k]
</code></pre>
<p>其实可以用  $O(n\log k)$ 的时间复杂度找到最小的 $k$ 个元素。有两种思路：</p>
<p>1、借助快速排序把数组一分为二的 partition 操作；</p>
<p>2、借助最大堆（需要把数组做一个转换，都变成相反数，最小的 $k$ 个数，就是最大堆里最大的 $k$ 个数）。</p>
<p>Python 代码1：partition，注意，这种方式，大于等于 pivot 的元素都被分在了右边</p>
<pre><code class="language-python">class Solution(object):
    def getLeastNumbers_Solution(self, input, k):
        &quot;&quot;&quot;
        :type input: list[int]
        :type k: int
        :rtype: list[int]
        &quot;&quot;&quot;
        size = len(input)

        if size == 0:
            return []
        if k == size:
            return sorted(input)
        l = 0
        r = size - 1
        while l &lt;= r:
            p = self.__partition(input, l, r)
            if p == k - 1:
                return sorted(input[:p + 1])
            elif p &gt; k - 1:
                # 此时  k-1  p
                r = p - 1
            else:
                # 此时 p k-1
                l = p + 1

    def __partition(self, input, left, right):
        # 只有一个数的时候，就没有必要 partition 了
        # 直接返回这个数的索引
        if left == right:
            return left
        pivot = input[left]

        j = left
        # [left + 1, j] 这个区间里的元素都严格小于 pivot
        for i in range(left + 1, right + 1):
            if input[i] &lt; pivot:
                j += 1
                input[i], input[j] = input[j], input[i]
        input[left], input[j] = input[j], input[left]
        return j


if __name__ == '__main__':
    input = [9, 14, 1, 16, 19, 13, 12]
    k = 4
    solution = Solution()
    result = solution.getLeastNumbers_Solution(input, k)
    print(result)
</code></pre>
<p>Python 代码2：最大堆</p>
<pre><code class="language-python">class Solution(object):

    def getLeastNumbers_Solution(self, input, k):
        &quot;&quot;&quot;
        :type input: list[int]
        :type k: int
        :rtype: list[int]
        &quot;&quot;&quot;
        size = len(input)
        if size == 0:
            return []
        if k == size:
            return sorted(input)
        import heapq

        l = []
        for num in input[:k]:
            heapq.heappush(l, -num)
        for num in input[k:]:
            top = l[0]
            if top &lt; -num:
                heapq.heappushpop(l, -num)
        return sorted([-num for num in l])
</code></pre>
<p>当然，Python 中的 <code>heapq</code> 直接就有获取最小 $k$ 个元素的方法。</p>
<p>Python 代码：</p>
<pre><code class="language-python">class Solution(object):

    def getLeastNumbers_Solution(self, input, k):
        &quot;&quot;&quot;
        :type input: list[int]
        :type k: int
        :rtype: list[int]
        &quot;&quot;&quot;
        size = len(input)
        if size == 0:
            return []
        if k == size:
            return sorted(input)
        import heapq
        heapq.heapify(input)
        return sorted(heapq.nsmallest(k, input))
</code></pre>
<p>Python 代码：两路 partition 的写法：</p>
<pre><code class="language-python">class Solution(object):
    def getLeastNumbers_Solution(self, input, k):
        &quot;&quot;&quot;
        :type input: list[int]
        :type k: int
        :rtype: list[int]
        &quot;&quot;&quot;

        size = len(input)

        if size == 0:
            return []
        if k == size:
            return sorted(input)
        l = 0
        r = size - 1
        while l &lt;= r:
            p = self.__partition(input, l, r)
            if p == k - 1:
                return sorted(input[:p + 1])
            elif p &gt; k - 1:
                # 此时  k-1  p
                r = p - 1
            else:
                # 此时 p k-1
                l = p + 1

    def __partition(self, input, left, right):
        # 只有一个数的时候，就没有必要 partition 了
        # 直接返回这个数的索引
        if left == right:
            return left
        pivot = input[left]
        l = left + 1
        r = right
        while True:
            while l &lt;= right and input[l] &lt;= pivot:
                l += 1
            while r &gt; left and input[r] &gt;= pivot:
                r -= 1
            if l &gt; r:
                break
            input[l], input[r] = input[r], input[l]
            l += 1
            r -= 1
        input[left], input[r] = input[r], input[left]
        return r
</code></pre>
<p>C++ 代码：</p>
<p><img alt="《剑指 Offer （第 2 版）》第 40 题：最小的 K 个数" src="http://upload-images.jianshu.io/upload_images/414598-21d5a413f726511c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>（本节完）</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
